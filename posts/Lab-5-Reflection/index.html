<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Lab 5 Reflection | TONY'S STUDIO</title><meta name="author" content="Tony Lewis"><meta name="copyright" content="Tony Lewis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#300303"><meta name="description" content="Reflection on 2023 BUAA OS Lab 5 - File System">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab 5 Reflection">
<meta property="og:url" content="https://blog.tonys-studio.top/posts/Lab-5-Reflection/">
<meta property="og:site_name" content="TONY&#39;S STUDIO">
<meta property="og:description" content="Reflection on 2023 BUAA OS Lab 5 - File System">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/14/09.jpeg">
<meta property="article:published_time" content="2023-05-06T03:47:42.000Z">
<meta property="article:modified_time" content="2025-08-13T10:02:55.659Z">
<meta property="article:author" content="Tony Lewis">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="BUAA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/14/09.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Lab 5 Reflection",
  "url": "https://blog.tonys-studio.top/posts/Lab-5-Reflection/",
  "image": "https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/14/09.jpeg",
  "datePublished": "2023-05-06T03:47:42.000Z",
  "dateModified": "2025-08-13T10:02:55.659Z",
  "author": [
    {
      "@type": "Person",
      "name": "Tony Lewis",
      "url": "https://tonys-studio.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/favicon.svg"><link rel="canonical" href="https://blog.tonys-studio.top/posts/Lab-5-Reflection/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-R6O16YoeQt"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#300303')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?68629f5da0a0c3347b896920fbf164b5";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "sthrplbt7c");
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":10,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":256,"languages":{"author":"Author: Tony Lewis","link":"Link: ","source":"Source: TONY'S STUDIO","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#871798","bgDark":"#C81025","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lab 5 Reflection',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-footer-beautify@1.0.6/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/css/barber-shop.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/back_img.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/avatar/avatar.png" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/missing.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">40</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-jedi fa-beat"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/14/09.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/logo.svg" alt="Logo"><span class="site-name">TONY'S STUDIO</span></a><a class="nav-page-title" href="/"><span class="site-name">Lab 5 Reflection</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-jedi fa-beat"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Lab 5 Reflection</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-06T03:47:42.000Z" title="Created May. 6th, 2023 - 11:47:42 11:47:42">May. 6th, 2023 - 11:47:42</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-08-13T10:02:55.659Z" title="Updated Aug. 13th, 2025 - 18:02:55 18:02:55">Aug. 13th, 2025 - 18:02:55</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA/">BUAA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA/OS/">OS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>41mins</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span class="waline-pageview-count" data-path="/posts/Lab-5-Reflection/"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/posts/Lab-5-Reflection/#post-comment"><span class="waline-comment-count" data-path="/posts/Lab-5-Reflection/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="BUAA-2023-Spring-OS"><a href="#BUAA-2023-Spring-OS" class="headerlink" title="BUAA 2023 Spring OS"></a>BUAA 2023 Spring OS</h1><hr>
<h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>In this lab, we finally come to <strong>File System</strong>. For MOS, a micro-kernel OS, file system serves as a process in user space, and all file operations are done via IPC between user process and this file system process. As we introduce file system to our OS, we have to deal with disk. Thus there is another part of code to handle memory and disk.</p>
<h2 id="Tips-for-Windows-Players"><a href="#Tips-for-Windows-Players" class="headerlink" title="Tips for Windows Players"></a>Tips for Windows Players</h2><p>If you do labs on Windows with Visual Studio and WSL, you may encounter some subtle errors. Expand this part if your seek for solutions. 🙃</p>
<details class="toggle"><summary class="toggle-button" style>Visual Studio Tips</summary><div class="toggle-content"><p>You may encounter an error saying that <code>DT_DIR</code> is undefined. It may not be a problem when you compile the project, but IntelliSense will show this as an error. Expand it if you have such </p>
<p>The reason is that, though with WSL, our code is on Windows, and we use MinGW (Minimal GNU for Windows). This macro is defined in standard <code>dirent.h</code> header file, but surrounded with a <code>#if</code> macro. Of course, <code>_WIN32</code> is not defined since our OS will be compiled on Linux. But <code>_BSD_SOURCE</code> is not defined neither! 😵‍💫</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dirent.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_BSD_SOURCE) || defined(_WIN32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_REG   	_A_NORMAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_DIR   	_A_SUBDIR</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>So, the solution is that, in the <code>CppProperties.json</code>, add <code>defines</code> entry in <code>configurations</code> with <code>_BSD_SOURCE</code> declared. The rest of the properties are omitted. This works only as a reminder to Visual Studio IntelliSense, so won’t have actual effect on our compilation and run.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;_BSD_SOURCE&quot;</span> <span class="punctuation">]</span> <span class="comment">// enable DT_DIR</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>If you don’t know what is <code>CppProperties.json</code> is, please refer to my previous post.</p>
<ul>
<li><a href="/posts/Configure-VS-for-Non-MSVC-Projects/">Configure-VS-for-Non-MSVC-Projects</a></li>
</ul>
</blockquote>
<h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><p>For Windows, the EOL (End of line) symbol is <code>CRLF</code> (<code>\r\n</code>), while for Linux, it is <code>LF</code> (<code>\n</code>). In this lab, you have to pay attention to this subtle difference, for it may cause slight errors. For example, the string in our code is “hello\n”, but in the file, it is “hello\r\n” if you accept the default <code>CRLF</code> on Windows. So, when doing string compare, these two strings will not match each other, while they should.</p>
<p>Files you should especially pay attention to are <code>tests/lab5_2/newmotd</code> and <code>tests/lab5_2/motd</code>.</p>
<p>You can also refer to this post to change default EOL when saving a file: <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/visualstudio/ide/encodings-and-line-breaks?view=vs-2022">Encodings and line endings</a>.</p>
<p><span class="hide-inline"><button type="button" class="hide-button" style>How did I find this?</button><span class="hide-content">By printing the length of the strings. 🤪</span></span></p>
</div></details>

<hr>
<h1 id="1-Disk-Access"><a href="#1-Disk-Access" class="headerlink" title="1. Disk Access"></a>1. Disk Access</h1><p>The purpose of the File System is to make memory persistent. But our RAM is not persistent. So before we formally introduce File System, we have to get pass hard disk.</p>
<h2 id="1-1-Device"><a href="#1-1-Device" class="headerlink" title="1.1 Device"></a>1.1 Device</h2><p>Disk, the same as all other devices, are accessed though the register it provides, and these registers are mapped to our kernel memory. So we can manipulate them by read and write certain memory range.</p>
<p>In <code>include/mmu.h</code>, we can see the memory layout of MOS. And you can find that devices are mapped to <code>kseg1</code>.</p>
<img src="/posts/Lab-5-Reflection/image-20230502224853429.png" alt="image-20230502224853429" style="zoom:50%;">

<p>I think now it is a good time for us to review memory accessing process.</p>
<img src="/posts/Lab-5-Reflection/image-20230502225148176.png" alt="image-20230502225148176" style="zoom:50%;">

<p>You can see that <code>kseg1</code> is the only segment that doesn’t go though cache. Ya know, you just cannot cache the input or output of keyboard, or any other devices.</p>
<h2 id="1-2-Read-Write-Device-Segment"><a href="#1-2-Read-Write-Device-Segment" class="headerlink" title="1.2 Read &amp; Write Device Segment"></a>1.2 Read &amp; Write Device Segment</h2><p>Now that we have to communicate with device by read and write <code>kseg1</code>, it is time to write such functions to do this job.</p>
<blockquote>
<p>Just like when we access kernel address using <code>KADDR</code> and <code>PADDR</code>, here, we also need such conversion between device address and its correspondent in <code>kseg1</code>. It can be really simple like this.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KSEG1ADDR(pa) ((pa) + KSEG1)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>As we know, such operations are done via system call. So here is the system call. <code>va</code> is the address of the value we want to write into or read out of the device located at address <code>pa</code>. And <code>len</code> is the length of data we want.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span>;</span><br></pre></td></tr></table></figure>

<p>For MOS, we have the following there devices, and they are fixed to certain <strong>physical</strong> addresses. The detailed info for them are defined in corresponding header files.</p>
<table>
<thead>
<tr>
<th align="center">Device</th>
<th align="center">Start Address</th>
<th align="center">Length</th>
<th align="center">Header File</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Console</td>
<td align="center">0x10000000</td>
<td align="center">0x20</td>
<td align="center"><code>include/drivers/dev_cons.h</code></td>
</tr>
<tr>
<td align="center">IDE Disk</td>
<td align="center">0x13000000</td>
<td align="center">0x4200</td>
<td align="center"><code>include/drivers/dev_disk.h</code></td>
</tr>
<tr>
<td align="center">RTC</td>
<td align="center">0x15000000</td>
<td align="center">0x200</td>
<td align="center"><code>include/drivers/dev_rtc.h</code></td>
</tr>
</tbody></table>
<details class="toggle"><summary class="toggle-button" style>sys_write/read_dev</summary><div class="toggle-content"><p>Before we read and write, we <strong>must</strong> validate address first.</p>
<details class="toggle"><summary class="toggle-button" style>Validate Address</summary><div class="toggle-content"><p>First, since File System runs in user space, the <code>va</code> is limited to user space only. So we can simply check it by verify if it is in user space range.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">is_illegal_va_range</span><span class="params">(u_long va, u_int len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> va + len &lt; va || va &lt; UTEMP || va + len &gt; UTOP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then, it is the physical address of device. Here I added a auxiliary range check function. For device address, we must make sure it is within one of the device memory range mentioned above.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">in_range</span><span class="params">(u_long base, u_int range, u_long begin, u_int len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (base &lt;= begin) &amp;&amp; (begin + len &lt;= base + range);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">is_illegal_dev_pa_range</span><span class="params">(u_long pa, u_int len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa + len &lt; pa)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(in_range(<span class="number">0x10000000</span>, <span class="number">0x20</span>,   pa, len) ||</span><br><span class="line">          in_range(<span class="number">0x13000000</span>, <span class="number">0x4200</span>, pa, len) ||</span><br><span class="line">          in_range(<span class="number">0x15000000</span>, <span class="number">0x200</span>,  pa, len)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>After address validation, we can read and write device as we will. Just use <code>memcpy</code> for memory exchange.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_write_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va_range(va, len) || is_illegal_dev_pa_range(pa, len))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)KSEG1ADDR(pa), (<span class="type">const</span> <span class="type">void</span>*)va, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va_range(va, len) || is_illegal_dev_pa_range(pa, len))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)va, (<span class="type">const</span> <span class="type">void</span>*)KSEG1ADDR(pa), len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Just notice that <code>pa</code> is the physical address, and we have to add <code>kseg1</code> offset to it.</p></div></details>

<h2 id="1-3-IDE-Read-Write"><a href="#1-3-IDE-Read-Write" class="headerlink" title="1.3 IDE Read &amp; Write"></a>1.3 IDE Read &amp; Write</h2><p>With <code>sys_read_dev</code> and <code>sys_write_dev</code>, we can communicate with device by read and write corresponding memory range. So it is time to really read and write data from disk. IDE (Integrated Drive Electronics) is a old-fashioned disk interface.</p>
<h3 id="1-3-1-IDE-Interface"><a href="#1-3-1-IDE-Interface" class="headerlink" title="1.3.1 IDE Interface"></a>1.3.1 IDE Interface</h3><p>Disk, you know, that structure. A disk is divided in to many sectors, and we can only get one, and only one sector by one read or write operation.  The address information about our IDE disk in MOS is as follows. The base address of IDE disk is 0x13000000, defined by macro <code>DEV_DISK_ADDRESS</code>. All offset below are based on this.</p>
<table>
<thead>
<tr>
<th align="center">Offset</th>
<th align="center">Macro</th>
<th align="center">Description</th>
<th align="center">Data Bytes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x0000</td>
<td align="center"><code>DEV_DISK_OFFSET</code></td>
<td align="center">read&#x2F;write offset to the 0 address of disk</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">0x0008</td>
<td align="center"><code>DEV_DISK_OFFSET_HIGH32</code></td>
<td align="center">high 32 bits of read&#x2F;write offset</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">0x0010</td>
<td align="center"><code>DEV_DISK_ID</code></td>
<td align="center">the ID of the disk to operate</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">0x0020</td>
<td align="center"><code>DEV_DISK_START_OPERATION</code></td>
<td align="center">set the disk to start read&#x2F;write operation</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">0x0030</td>
<td align="center"><code>DEV_DISK_STATUS</code></td>
<td align="center">return status of disk</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">0x4000</td>
<td align="center"><code>DEV_DISK_BUFFER</code></td>
<td align="center">buffer with the size of a sector</td>
<td align="center">512</td>
</tr>
</tbody></table>
<p>Disk is large, so 4 bytes of 4G memory range may be not enough. So you can use high 32 bit to manipulate on larger memory.</p>
<p>Often, we may have more than one disk, so we should specify which disk to operate. But here in MOS, we only have one, whose ID is, of course, 0.</p>
<p><code>DEV_DISK_START_OPERATION</code> indicates the following operation is a read or write. It is either <code>DEV_DISK_OPERATION_READ</code> or <code>DEV_DISK_OPERATION_WRITE</code>.</p>
<p><code>DEV_DISK_STATUS</code> will store the return value of the disk operation. Just read the value from this memory. 0 indicates error.</p>
<p><code>DEV_DISK_BUFFER</code>, well, it is literally the buffer that store the content of a sector, whether it will be written into or loaded from the disk.</p>
<h3 id="1-3-2-IDE-Operation"><a href="#1-3-2-IDE-Operation" class="headerlink" title="1.3.2 IDE Operation"></a>1.3.2 IDE Operation</h3><p>As we’re familiar with IDE Interface, we can now read and write data through it. Notice that, whenever we read or write, we do this one sector a time. Here is the declaration of read and write operation. You can see that we do these sector by sector.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span>* dst, u_int nsecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span>* src, u_int nsecs)</span>;</span><br></pre></td></tr></table></figure>

<p>You may notice that these are put in <code>serv.h</code>, which is the header file for File System process. Well, this perhaps because that disk operation is needed for File System.</p>
<p>To set or read registers or buffer, we can simple use the functions we wrote in <code>1.2</code>. So it can be relatively easy.</p>
<details class="toggle"><summary class="toggle-button" style>ide_read/write</summary><div class="toggle-content"><p>The detailed process of read&#x2F;write IDE disk is that, set disk ID and offset first, then begin read or write, and at last, get the return value. Just notice that, the order of start operation and prepare buffer memory is different. Since we have to fill buffer before we write it into the disk, and we can only get the valid memory after we read it from the disk.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span>* dst, u_int nsecs)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_int begin = secno * BY2SECT;</span><br><span class="line">    u_int end = begin + nsecs * BY2SECT;</span><br><span class="line">    u_int read_flag = DEV_DISK_OPERATION_READ;</span><br><span class="line">    u_int ret;</span><br><span class="line">    <span class="keyword">for</span> (u_int offset = <span class="number">0</span>; begin + offset &lt; end; offset += BY2SECT)</span><br><span class="line">    &#123;</span><br><span class="line">        u_int dev_offset = begin + offset;</span><br><span class="line">        panic_on(syscall_write_dev(&amp;diskno,</span><br><span class="line">                                   DEV_DISK_ADDRESS + DEV_DISK_ID,</span><br><span class="line">                                   <span class="keyword">sizeof</span>(diskno)));</span><br><span class="line">        panic_on(syscall_write_dev(&amp;dev_offset,</span><br><span class="line">                                   DEV_DISK_ADDRESS + DEV_DISK_OFFSET,</span><br><span class="line">                                   <span class="keyword">sizeof</span>(dev_offset)));</span><br><span class="line">        <span class="comment">// read start</span></span><br><span class="line">        panic_on(syscall_write_dev(&amp;read_flag,</span><br><span class="line">                                   DEV_DISK_ADDRESS + DEV_DISK_START_OPERATION,</span><br><span class="line">                                   <span class="keyword">sizeof</span>(read_flag)));</span><br><span class="line">        panic_on(syscall_read_dev(dst + offset,</span><br><span class="line">                                  DEV_DISK_ADDRESS + DEV_DISK_BUFFER,</span><br><span class="line">                                  BY2SECT));</span><br><span class="line">        <span class="comment">// read end</span></span><br><span class="line">        panic_on(syscall_read_dev(&amp;ret,</span><br><span class="line">                                  DEV_DISK_ADDRESS + DEV_DISK_STATUS,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(ret)));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)   <span class="comment">// failed</span></span><br><span class="line">            user_panic(<span class="string">&quot;ide_read failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span>* src, u_int nsecs)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_int begin = secno * BY2SECT;</span><br><span class="line">    u_int end = begin + nsecs * BY2SECT;</span><br><span class="line">    u_int write_flag = DEV_DISK_OPERATION_WRITE;</span><br><span class="line">    u_int ret;</span><br><span class="line">    <span class="keyword">for</span> (u_int offset = <span class="number">0</span>; begin + offset &lt; end; offset += BY2SECT)</span><br><span class="line">    &#123;</span><br><span class="line">        u_int dev_offset = begin + offset;</span><br><span class="line">        panic_on(syscall_write_dev(&amp;diskno,</span><br><span class="line">                                   DEV_DISK_ADDRESS + DEV_DISK_ID,</span><br><span class="line">                                   <span class="keyword">sizeof</span>(diskno)));</span><br><span class="line">        panic_on(syscall_write_dev(&amp;dev_offset,</span><br><span class="line">                                   DEV_DISK_ADDRESS + DEV_DISK_OFFSET,</span><br><span class="line">                                   <span class="keyword">sizeof</span>(dev_offset)));</span><br><span class="line">        <span class="comment">// write begin</span></span><br><span class="line">        panic_on(syscall_write_dev(src + offset,</span><br><span class="line">                                   DEV_DISK_ADDRESS + DEV_DISK_BUFFER,</span><br><span class="line">                                   BY2SECT));</span><br><span class="line">        panic_on(syscall_write_dev(&amp;write_flag,</span><br><span class="line">                                   DEV_DISK_ADDRESS + DEV_DISK_START_OPERATION,</span><br><span class="line">                                   <span class="keyword">sizeof</span>(write_flag)));</span><br><span class="line">        <span class="comment">// write end</span></span><br><span class="line">        panic_on(syscall_read_dev(&amp;ret,</span><br><span class="line">                                  DEV_DISK_ADDRESS + DEV_DISK_STATUS,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(ret)));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)	<span class="comment">// failed</span></span><br><span class="line">            user_panic(<span class="string">&quot;ide_write failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Well, we cannot handle disk hardware error, so we simply panic on any error.</p>
<blockquote>
<p><strong>Tips:</strong> Here, we should use <code>user_panic</code>, rather than <code>panic</code>. Since the latter one is for kernel.</p>
</blockquote>
</div></details>

<hr>
<h1 id="2-File-System"><a href="#2-File-System" class="headerlink" title="2. File System"></a>2. File System</h1><h2 id="2-1-Disk-Layout"><a href="#2-1-Disk-Layout" class="headerlink" title="2.1 Disk Layout"></a>2.1 Disk Layout</h2><p>The basic unit in disk is sector, as we already know. But a sector is only of 512 bytes, which is a little small, thus will make too many of them. So the File System merge multiple sectors into one <strong>block</strong> as the basic unit for Operating System. Usually, one block is of the same size as page.</p>
<blockquote>
<p>There are some macros in MOS for such conversions.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include/fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2BLK BY2PG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT2BLK (BY2BLK * 8)</span></span><br><span class="line"><span class="comment">// fs/serv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2SECT 512                 <span class="comment">// bytes of a sector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECT2BLK (BY2BLK / BY2SECT) <span class="comment">// how many sectors in a block (8)</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>And it is easy to imagine the layout of those blocks. Later, when we read or write disk, we always read or write a complete block, i.e. read or write multiple sectors in a row.</p>
<img src="/posts/Lab-5-Reflection/Disk-Layout.svg" alt="Disk-Layout" style="zoom:80%;">

<p>Block 0 stores the bootloader, and partition table of the disk. Super block stores the key information about the disk - the magic number, number of blocks and root directory. By reading this, our File System can know the general information about the blocks.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> s_magic;   <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">	<span class="type">uint32_t</span> s_nblocks; <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span> <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>And the following several blocks are bitmap blocks. The number of it depends on the size of the disk. If there are N blocks, then there must be enough bitmap blocks to hold these N bits. You can get it by a simple division, just make sure there are enough bits.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nbitblock = (NBLOCK + BIT2BLK - <span class="number">1</span>) / BIT2BLK;</span><br><span class="line">nbitblock = NBLOCK / BIT2BLK + !!(NBLOCK % BIT2BLK); <span class="comment">// Or this</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-Block-Cache-in-Memory"><a href="#2-2-Block-Cache-in-Memory" class="headerlink" title="2.2 Block Cache in Memory"></a>2.2 Block Cache in Memory</h2><p>In MOS, there is a wired design, I think, that map disk blocks to File System process’s memory. And here is how this is done.</p>
<img src="/posts/Lab-5-Reflection/Block-Cache.svg" alt="Block-Cache" style="zoom:80%;">

<p>As you can see, we mapped disk to memory block by block. Now you can see why I say wired, because it will limit our disk size to 1GB only. 😢</p>
<blockquote>
<p>There are two macros for this mapping that indicate the address range for such cache.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAP 0x10000000 <span class="comment">// cache map start address</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAX 0x40000000 <span class="comment">// maximum disk size</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>Such mapping is quite easy, as it is one-to-one. So we just add a offset to block ID (<code>bno</code>&#x2F;<code>blockno</code> in code) to convert it into corresponding virtual address. So we have this function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">diskaddr</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>

<details class="toggle"><summary class="toggle-button" style>diskaddr</summary><div class="toggle-content"><p>Just remember to validate address range.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">diskaddr</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_long va = (DISKMAP + blockno * BY2BLK);</span><br><span class="line">    panic_on(va &lt; DISKMAP);</span><br><span class="line">    panic_on(va &gt;= DISKMAP + DISKMAX);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)va;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>Things become easier as block and page are of the same size. When we cache a block, we simple get its virtual address in memory via <code>diskaddr</code> function, and then allocate a page to store it.</p>
<h2 id="2-3-Block-Management"><a href="#2-3-Block-Management" class="headerlink" title="2.3 Block Management"></a>2.3 Block Management</h2><p>The fundamental work for File System is to manage all these blocks. As we know, it uses bitmap to record the use of blocks, so the basic mechanism is clear and set corresponding bits. And of course, allocate and free blocks when necessary.</p>
<h3 id="2-3-1-Block-Initialization"><a href="#2-3-1-Block-Initialization" class="headerlink" title="2.3.1 Block Initialization"></a>2.3.1 Block Initialization</h3><p>All these are actually done in File System process. So let’s have a brief look at it. Here is its main function.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    user_assert(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> File) == BY2FILE);</span><br><span class="line">    debugf(<span class="string">&quot;FS is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    serve_init();</span><br><span class="line">    fs_init();</span><br><span class="line">    serve();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can see that, it first initialize it self, then initialize File System, and at last, serve as File System. Here, we just need to know <code>fs_init</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv/c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    read_super();</span><br><span class="line">    check_write_block();</span><br><span class="line">    read_bitmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Still, is separated into small tasks. First one is to read the Super block to get block info. Then, I think, is a self diagnose, read it as you will. And the last one is to read the bitmap block to get the current disk usage.</p>
<details class="toggle"><summary class="toggle-button" style>read_bitmap</summary><div class="toggle-content"><blockquote>
<p>Related functions will be introduced later. 😉</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/fs.c</span></span><br><span class="line"><span class="type">uint32_t</span>* bitmap;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_bitmap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* blk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Calculate the number of the bitmap blocks, and read them into memory.</span></span><br><span class="line">    u_int nbitmap = super-&gt;s_nblocks / BIT2BLK + !!(super-&gt;s_nblocks % BIT2BLK);</span><br><span class="line">    <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; nbitmap; i++)</span><br><span class="line">        read_block(i + <span class="number">2</span>, blk, <span class="number">0</span>);</span><br><span class="line">    bitmap = diskaddr(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Make sure the reserved and root blocks are marked in-use.</span></span><br><span class="line">    user_assert(!block_is_free(<span class="number">0</span>));</span><br><span class="line">    user_assert(!block_is_free(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: Make sure all bitmap blocks are marked in-use.</span></span><br><span class="line">    <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; nbitmap; i++)</span><br><span class="line">        user_assert(!block_is_free(i + <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    debugf(<span class="string">&quot;read_bitmap is good\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h3 id="2-3-2-Block-Mapping"><a href="#2-3-2-Block-Mapping" class="headerlink" title="2.3.2 Block Mapping"></a>2.3.2 Block Mapping</h3><p>As mentioned above, we cache blocks in memory, so we have to maintain such mapping. It involves these two functions below. Mapping block is actually allocating a page for the block, and link it virtual address to the page.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">map_block</span><span class="params">(u_int blockno)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap_block</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Actually, in Lab 5, <code>unmap_block</code> is not declared in <code>fs/serv.h</code>. They are in <code>tests/lab5_3/mix_check.c</code>. Err… And in our File System, we don’t yet use it. Perhaps not the time?</p>
</blockquote>
<p>Before we handle these functions, let’s take a look at some auxiliary functions.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">block_is_mapped</span><span class="params">(u_int blockno)</span>; <span class="comment">// return mapped va if is mapped</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_free</span><span class="params">(u_int blockno)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_dirty</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In bitmap, 1 represents free state.</p>
</blockquote>
<details class="toggle"><summary class="toggle-button" style>block_is_xxx</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">block_is_mapped</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* va = diskaddr(blockno);</span><br><span class="line">    <span class="keyword">if</span> (va_is_mapped(va))</span><br><span class="line">        <span class="keyword">return</span> va;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_free</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_dirty</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* va = diskaddr(blockno);</span><br><span class="line">    <span class="keyword">return</span> va_is_mapped(va) &amp;&amp; va_is_dirty(va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>bitmap</code> is a <code>u_int</code> array, one unit in bitmap is 4 Bytes, 32 bits. One <code>u_int</code> can store 32 bits, so that’s what 32 means here.</p>
</blockquote>
<p>Actually the mapping status of block can be presented by that of the virtual address it corresponds to.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">va_is_mapped</span><span class="params">(<span class="type">void</span>* va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (vpd[PDX(va)] &amp; PTE_V) &amp;&amp; (vpt[VPN(va)] &amp; PTE_V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">va_is_dirty</span><span class="params">(<span class="type">void</span>* va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> vpt[VPN(va)] &amp; PTE_DIRTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>With these auxiliary functions, it would be easy to map blocks.</p>
<details class="toggle"><summary class="toggle-button" style>map_block</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">map_block</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Step 1: If the block is already mapped in cache, return 0.</span></span><br><span class="line">    <span class="keyword">if</span> (block_is_mapped(blockno))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Alloc a page in permission &#x27;PTE_D&#x27; via syscall.</span></span><br><span class="line">    <span class="comment">// Hint: syscall_mem_alloc will link va to the new page automatically.</span></span><br><span class="line">    <span class="keyword">return</span> syscall_mem_alloc(<span class="number">0</span>, diskaddr(blockno), PTE_D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap_block</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Step 1: Get the mapped address of the cache page of this block</span></span><br><span class="line">    <span class="type">void</span>* va = block_is_mapped(blockno);</span><br><span class="line">    <span class="keyword">if</span> (!va)    <span class="comment">// not mapped</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: If this block is used (not free) and dirty in cache, write it back</span></span><br><span class="line">    <span class="comment">// to the disk first.</span></span><br><span class="line">    <span class="keyword">if</span> (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno))</span><br><span class="line">        write_block(blockno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: Unmap the virtual address via syscall.</span></span><br><span class="line">    syscall_mem_unmap(<span class="number">0</span>, va);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure block is unmapped.</span></span><br><span class="line">    user_assert(!block_is_mapped(blockno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h3 id="2-3-3-Block-Allocation"><a href="#2-3-3-Block-Allocation" class="headerlink" title="2.3.3 Block Allocation"></a>2.3.3 Block Allocation</h3><p>Then, we got to handle block allocation. Here are the declaration of related functions. Just allocate and free, huh?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_block</span><span class="params">(u_int blockno)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The same as <code>unmap_block</code>, <code>free_block</code> is also declared in <code>tests/lab5_3/mix_check.c</code> with the same reason I guessed.</p>
</blockquote>
<p>To allocate a block, we have to traverse all blocks to find the first free block, because we want to make use of limited number of blocks. Then, we just modify the bitmap block to mark it allocated.</p>
<blockquote>
<p><strong>Important!</strong> As we modified the bitmap block, we got to write it back to the disk to make the change persistent.</p>
</blockquote>
<p>There are two steps in <code>alloc_block</code>. First, we should allocate a block, just allocate one by marking it allocated. Then, we use <code>map_block</code> to map it to its virtual address.</p>
<details class="toggle"><summary class="toggle-button" style>alloc_block</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r, bno;</span><br><span class="line">    <span class="comment">// Step 1: find a free block.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = alloc_block_num()) &lt; <span class="number">0</span>)  <span class="comment">// failed</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    bno = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: map this block into memory.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>)     <span class="comment">// failed</span></span><br><span class="line">    &#123;</span><br><span class="line">        free_block(bno);  <span class="comment">// exception safe rollback</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: return the allocated block number.</span></span><br><span class="line">    <span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Real allocation and return the block id.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block_num</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walk through this bitmap, find a free one and mark it as used, then sync</span></span><br><span class="line"><span class="comment">     * this block to IDE disk from memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> blockno = <span class="number">3</span>; blockno &lt; super-&gt;s_nblocks; blockno++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            bitmap[blockno / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Write the affected bitmap block to disk. (blockno / BIT2BLK)</span></span><br><span class="line"><span class="comment">             * is the bitmap block order, 2 is the reserved two blocks.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            write_block(blockno / BIT2BLK + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> blockno;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -E_NO_DISK;  <span class="comment">// no free blocks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p><code>free_block</code> is relatively simpler. Since here we cache blocks, so there’s no need to free the page. We can reuse the page next time.</p>
<details class="toggle"><summary class="toggle-button" style>free_block</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_block</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Step 1: If &#x27;blockno&#x27; is invalid, return.</span></span><br><span class="line">    <span class="keyword">if</span> ((blockno == <span class="number">0</span>) || (blockno &gt;= super-&gt;s_nblocks))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Set the flag bit of &#x27;blockno&#x27; in &#x27;bitmap&#x27;.</span></span><br><span class="line">    bitmap[blockno / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h3 id="2-3-4-Read-Write-Block"><a href="#2-3-4-Read-Write-Block" class="headerlink" title="2.3.4 Read &amp; Write Block"></a>2.3.4 Read &amp; Write Block</h3><p>Finally, we just need to read and write block to finish this part.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/fs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_block</span><span class="params">(u_int blockno, <span class="type">void</span>** blk, u_int* isnew)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_block</span><span class="params">(u_int blockno)</span>;</span><br></pre></td></tr></table></figure>

<details class="toggle"><summary class="toggle-button" style>read/write_block</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/fs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_block</span><span class="params">(u_int blockno, <span class="type">void</span>** blk, u_int* isnew)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Step 1: validate blockno. Make file the block to read is within the disk.</span></span><br><span class="line">    <span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">        user_panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: validate this block is used, not free.</span></span><br><span class="line">    <span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">        user_panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: transform block number to corresponding virtual address.</span></span><br><span class="line">    <span class="type">void</span>* va = diskaddr(blockno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4: read disk and set *isnew.</span></span><br><span class="line">    <span class="keyword">if</span> (block_is_mapped(blockno))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the block is already in memory</span></span><br><span class="line">        <span class="keyword">if</span> (isnew)</span><br><span class="line">            *isnew = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the block is not in memory, and will be cached the first time</span></span><br><span class="line">        <span class="keyword">if</span> (isnew)</span><br><span class="line">            *isnew = <span class="number">1</span>;</span><br><span class="line">        map_block(blockno);	<span class="comment">// map (cache) block into memory</span></span><br><span class="line">        ide_read(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5: if blk != NULL, assign &#x27;va&#x27; to &#x27;*blk&#x27;.</span></span><br><span class="line">    <span class="keyword">if</span> (blk)</span><br><span class="line">        *blk = va;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_block</span><span class="params">(u_int blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Step 1: detect if this block is mapped, if not, can&#x27;t write it&#x27;s data to disk.</span></span><br><span class="line">    <span class="keyword">if</span> (!block_is_mapped(blockno))</span><br><span class="line">        user_panic(<span class="string">&quot;write unmapped block %08x&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step2: write data to IDE disk. (using ide_write, and the diskno is 0)</span></span><br><span class="line">    ide_write(<span class="number">0</span>, blockno * SECT2BLK, diskaddr(blockno), SECT2BLK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h2 id="2-4-File-Layout"><a href="#2-4-File-Layout" class="headerlink" title="2.4 File Layout"></a>2.4 File Layout</h2><h3 id="2-4-1-File-Block"><a href="#2-4-1-File-Block" class="headerlink" title="2.4.1 File &amp; Block"></a>2.4.1 File &amp; Block</h3><p>Although block is fundamental for File System, users cannot accept such low level concept. So we use files to cover all these ugly stuffs. Here is a good figure to show the mechanism of how file covers block.</p>
<img src="/posts/Lab-5-Reflection/File-Layout.svg" alt="File-Layout" style="zoom:80%;">

<blockquote>
<p>Since the blocks are stored as type <code>struct Block</code>, we can simple access them by subscription, so in <code>struct File</code>, we can only record the index of the block it has. <code>File::f_indirect</code> uses a block if necessary to store more direct links. We can get the number of blocks of a file using its size. Let’s assume there is a <code>File* file</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nblk = file-&gt;f_size / BY2BLK;</span><br></pre></td></tr></table></figure>

<p>Then we could have this conversion from file block id to disk block id. To make it easier, we simply omitted the first 10 (<code>NDIRECT</code>) links in the indirect block to make file block id continuous. Thus we could have such code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; NDIRECT)</span><br><span class="line">     bno = file-&gt;f_direct[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     bno = ((<span class="type">uint32_t</span>*)blocks[file-&gt;f_indirect])[i];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Notice</strong>: These two are just pseudo-code.</p>
</blockquote>
</blockquote>
<p>And here is the actual declaration of file.</p>
<details class="toggle"><summary class="toggle-button" style>struct File</summary><div class="toggle-content"><p>This is in <code>fs/fs.h</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum size of a filename (a single path component), including null.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNAMELEN 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum size of a complete pathname, including null.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPATHLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of (direct) block pointers in a File descriptor.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BY2BLK / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum file size on disk.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILESIZE (NINDIRECT * BY2BLK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2FILE 256  <span class="comment">// size of struct File</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line">    <span class="type">uint32_t</span> f_size;         <span class="comment">// file size in bytes</span></span><br><span class="line">    <span class="type">uint32_t</span> f_type;         <span class="comment">// file type</span></span><br><span class="line">    <span class="type">uint32_t</span> f_direct[NDIRECT];</span><br><span class="line">    <span class="type">uint32_t</span> f_indirect;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the pointer to the directory where this file is in, valid only in memory.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span>* <span class="title">f_dir</span>;</span></span><br><span class="line">    <span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span>*)];</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE2BLK (BY2BLK / sizeof(struct File))  <span class="comment">// 16</span></span></span><br></pre></td></tr></table></figure>
</div></details>

<p>We can see that, there are 1024 (<code>NINDIRECT</code>) links available, which means a file can have at most 1024 blocks. Thus the maximum file size our MOS can handle is <code>4M</code>.</p>
<blockquote>
<p><strong>Notice</strong>: It seems, our filename is the absolute path name. 😧</p>
</blockquote>
<p>ℹ If you want to know how exactly we get disk block id from file block id, hold your horse! I’ll talk about them in <code>2.4.4</code>. 🙂</p>
<h3 id="2-4-2-File-Descriptor"><a href="#2-4-2-File-Descriptor" class="headerlink" title="2.4.2 File Descriptor"></a>2.4.2 File Descriptor</h3><p>In Linux, when we open a file using UNIX style <code>open</code>, we will get a file descriptor representing the file we opened. The same goes with MOS. Let’s see its definition.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include/fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_int fd_dev_id;</span><br><span class="line">    u_int fd_offset;</span><br><span class="line">    u_int fd_omode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">    u_int f_fileid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct Fd</code> is the basic description of a file, it indicate the file is a regular file, a console or a pipe, and some basic information. Then, <code>struct Filefd</code> is the specific descriptor for file.</p>
<p>We arrange an area in the memory for file descriptor and file content, and they can be accessed via a simple conversion. Here is the layout of file descriptor and content in a process’ memory.</p>
<img src="/posts/Lab-5-Reflection/File-Address.svg" alt="File-Address" style="zoom:80%;">

<blockquote>
<p><strong>Important!</strong> Now we’ve had this layout in our mind. Remember, the address in file descriptor table is the same as the address of <code>struct Fd</code> and <code>struct Filefd</code>. So… Did you notice that? The first member in <code>struct Filefd</code> is just <code>struct Fd</code>, which means we can simply apply force conversion between them, or get them directly from the virtual address.</p>
</blockquote>
<p>In MOS, we support at most 32 (<code>MAXFD</code>) file descriptors for one process. We want to make file descriptor table to take up a whole page directory, so we just make it a 4 MB segment. We assign 4 KB for each <code>struct Filefd</code>, and each of them corresponds to a 4 MB size segment as the content of the file. The conversion can be simple.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/fd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFD 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEBASE 0x60000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDTABLE  (FILEBASE - PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i)   (FDTABLE  + (i) * BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i) (FILEBASE + (i) * PDMAP)</span></span><br><span class="line"><span class="comment">// user/lib/fd.c</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fd2data</span><span class="params">(<span class="keyword">struct</span> Fd* fd)</span> &#123; <span class="keyword">return</span> (<span class="type">void</span>*)INDEX2DATA(fd2num(fd)); &#125;</span><br><span class="line"><span class="type">int</span>   <span class="title function_">fd2num</span><span class="params">(<span class="keyword">struct</span> Fd* fd)</span>  &#123; <span class="keyword">return</span> ((u_int)fd - FDTABLE) / BY2PG; &#125;</span><br><span class="line"><span class="type">int</span>   <span class="title function_">num2fd</span><span class="params">(<span class="type">int</span> fd)</span>         &#123; <span class="keyword">return</span> FDTABLE + fd * BY2PG; &#125;</span><br></pre></td></tr></table></figure>

<p>So when we open a file, we first prepare the file descriptor, then map the file to its 4 MB segment.</p>
<blockquote>
<p>Previously, we know that MOS can only handle 4 MB file. So this is enough.</p>
</blockquote>
<h3 id="2-4-3-Allocate-Free-File-Descriptor"><a href="#2-4-3-Allocate-Free-File-Descriptor" class="headerlink" title="2.4.3 Allocate &amp; Free File Descriptor"></a>2.4.3 Allocate &amp; Free File Descriptor</h3><p>Well, the arrangement of these two function is not that pleasing. Perhaps due the the use of them. <code>fd_alloc</code> is used by more functions when opening different devices, while close can handle all devices.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include/fd.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fd_alloc</span><span class="params">(<span class="keyword">struct</span> Fd** fd)</span>;</span><br><span class="line"><span class="comment">// user/lib/fd.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fd_close</span><span class="params">(<span class="keyword">struct</span> Fd* fd)</span>;</span><br></pre></td></tr></table></figure>

<p>When we allocate a file descriptor, we only <strong>find</strong> the first empty 4 KB segment, and return its virtual address. We <strong>do not</strong> allocate page for it yet! The page allocation will be done later when initialize the descriptor by File System process. So when we close a file descriptor, we simple un-map the page from the virtual address.</p>
<details class="toggle"><summary class="toggle-button" style>fd_alloc/close</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_alloc</span><span class="params">(<span class="keyword">struct</span> Fd** fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (u_int fdno = <span class="number">0</span>; fdno &lt; MAXFD - <span class="number">1</span>; fdno++)</span><br><span class="line">    &#123;</span><br><span class="line">        u_int va = INDEX2FD(fdno);</span><br><span class="line">        <span class="keyword">if</span> ((vpd[VPD(va)] &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Later, a new page directory entry will be</span></span><br><span class="line">            <span class="comment">// created at the same time.</span></span><br><span class="line">            *fd = (<span class="keyword">struct</span> Fd*)va;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((vpt[VPN(va)] &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *fd = (<span class="keyword">struct</span> Fd*)va;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fd_close</span><span class="params">(<span class="keyword">struct</span> Fd* fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall_mem_unmap(<span class="number">0</span>, fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>One more thing, when we want to look up a file descriptor, we use the id of the file descriptor (what we get from <code>fd2num</code>). We cannot find the file descriptor immediately after <code>fd_alloc</code>, since then, no actual page is allocated. We can only get it after File System initialized it for us.</p>
<details class="toggle"><summary class="toggle-button" style>fd_lookup</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_lookup</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Fd** fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fdnum &gt;= MAXFD)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    u_int va = INDEX2FD(fdnum);</span><br><span class="line">    <span class="keyword">if</span> ((vpt[VPN(va)] &amp; PTE_V) != <span class="number">0</span>)  <span class="comment">// fd is used</span></span><br><span class="line">    &#123;</span><br><span class="line">        *fd = (<span class="keyword">struct</span> Fd*)va;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h3 id="2-4-4-Traverse-File-Blocks"><a href="#2-4-4-Traverse-File-Blocks" class="headerlink" title="2.4.4 Traverse File Blocks"></a>2.4.4 Traverse File Blocks</h3><p>We can use <code>file_block_walk</code> to get the corresponding <strong>disk block id</strong> of the given <strong>file block id</strong>. This one is quite similar to its peer <code>pgdir_walk</code>. And we wrap it to do the conversion from file block id to disk block id as <code>file_map_block</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/fs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_map_block</span><span class="params">(<span class="keyword">struct</span> File* f, u_int filebno, u_int* diskbno, u_int alloc)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File* f, u_int filebno, <span class="type">uint32_t</span>** ppdiskbno, u_int alloc)</span>;</span><br></pre></td></tr></table></figure>

<details class="toggle"><summary class="toggle-button" style>file_map_block</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/fs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_map_block</span><span class="params">(<span class="keyword">struct</span> File* f, u_int filebno, u_int* diskbno, u_int alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">// I think this pointer is redundant. We can simply use</span></span><br><span class="line">	<span class="comment">// uint32_t bno instead.</span></span><br><span class="line">	<span class="type">uint32_t</span>* ptr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: find the pointer for the target block.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: if the block not exists, and create is set, alloc one.</span></span><br><span class="line">	<span class="keyword">if</span> (*ptr == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (alloc == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">		*ptr = r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: set the pointer to the block in *diskbno and return 0.</span></span><br><span class="line">	*diskbno = *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<details class="toggle"><summary class="toggle-button" style>file_block_walk</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File* f, u_int filebno, <span class="type">uint32_t</span>** ppdiskbno, u_int alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">uint32_t</span>* ptr; <span class="comment">// ptr is the address of diskbno, so *ptr is diskbno</span></span><br><span class="line">    <span class="type">uint32_t</span>* blk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filebno &lt; NDIRECT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Step 1: if the target block is corresponded to a direct pointer, just return the</span></span><br><span class="line">        <span class="comment">// disk block number.</span></span><br><span class="line">        ptr = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (filebno &lt; NINDIRECT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Step 2: if the target block is corresponded to the indirect block, but there&#x27;s no</span></span><br><span class="line">        <span class="comment">//  indirect block and `alloc` is set, create the indirect block.</span></span><br><span class="line">        <span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (alloc == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">            <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            f-&gt;f_indirect = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Step 3: read the new indirect block to memory.</span></span><br><span class="line">        <span class="keyword">if</span> ((r = read_block(f-&gt;f_indirect, (<span class="type">void</span>**)&amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        ptr = blk + filebno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4: store the result into *ppdiskbno, and return 0.</span></span><br><span class="line">    *ppdiskbno = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>I just don’t understand why here we pass <code>diskbno</code> as a double-pointer, which, obviously, can be done via a simple pointer. ☹️</p>
</blockquote>
</div></details>

<p>Similarly, we have <code>file_get_block</code> to directly get the block content from its file block id.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int blockno, <span class="type">void</span> **pblk)</span>;</span><br></pre></td></tr></table></figure>

<details class="toggle"><summary class="toggle-button" style>file_get_block</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/fs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File* f, u_int filebno, <span class="type">void</span>** blk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int diskbno;</span><br><span class="line">	u_int isnew;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: find the disk block number is `f` using `file_map_block`.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: read the data in this disk to blk.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h2 id="2-5-File-Operations"><a href="#2-5-File-Operations" class="headerlink" title="2.5 File Operations"></a>2.5 File Operations</h2><p>Finally, we should provide interface for user processes to manipulate files. All our file operation are handed to File System process via IPC, and File System will do all stuffs for us and deliver necessary data back to us. Here I just list some of them.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, u_int omode, <span class="keyword">struct</span> Fd* fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_map</span><span class="params">(u_int fileid, u_int offset, <span class="type">void</span>* dstva)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_close</span><span class="params">(u_int fileid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>For more information on how File System process handle these requests, please refer to may another post.</p>
<ul>
<li><a href="../File-System-IPC/">File System IPC</a></li>
</ul>
</blockquote>
<p>File operations are provided to users by library functions, such as <code>open</code> and <code>close</code>, <code>read</code> and <code>write</code>.</p>
<h3 id="2-5-1-Device-Interface"><a href="#2-5-1-Device-Interface" class="headerlink" title="2.5.1 Device Interface"></a>2.5.1 Device Interface</h3><p>After we open a file, or to be more general, open a device, we can just do many operations just using device, instead of by requesting File System. We have three types of devices, and each can be represented by a <code>Device</code> structure. Are we getting it? We are using function pointers to achieve polymorphism.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dev_id;</span><br><span class="line">    <span class="type">char</span>* dev_name;</span><br><span class="line">    <span class="type">int</span> (*dev_read) (<span class="keyword">struct</span> Fd*, <span class="type">void</span>*, u_int, u_int);</span><br><span class="line">    <span class="type">int</span> (*dev_write)(<span class="keyword">struct</span> Fd*, <span class="type">const</span> <span class="type">void</span>*, u_int, u_int);</span><br><span class="line">    <span class="type">int</span> (*dev_close)(<span class="keyword">struct</span> Fd*);</span><br><span class="line">    <span class="type">int</span> (*dev_stat) (<span class="keyword">struct</span> Fd*, <span class="keyword">struct</span> Stat*);</span><br><span class="line">    <span class="type">int</span> (*dev_seek) (<span class="keyword">struct</span> Fd*, u_int);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Then we have these three devices.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devcons</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devpipe</span>;</span></span><br></pre></td></tr></table></figure>

<p>Then, let’s see how <code>devfile</code> is initialized. So the problem now is how these concrete functions are implemented.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span> &#123;</span><br><span class="line">    .dev_id    = <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    .dev_name  = <span class="string">&quot;file&quot;</span>,</span><br><span class="line">    .dev_read  = file_read,</span><br><span class="line">    .dev_write = file_write,</span><br><span class="line">    .dev_close = file_close,</span><br><span class="line">    .dev_stat  = file_stat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>file_read</code> reads n bytes from the given file from given offset.</p>
<details class="toggle"><summary class="toggle-button" style>file_read</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">file_read</span><span class="params">(<span class="keyword">struct</span> Fd* fd, <span class="type">void</span>* buf, u_int n, u_int offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span>* <span class="title">f</span> =</span> (<span class="keyword">struct</span> Filefd*)fd;</span><br><span class="line">    u_int size = f-&gt;f_file.f_size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Avoid reading past the end of file.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (offset + n &gt; size)</span><br><span class="line">        n = size - offset;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, (<span class="type">char</span>*)fd2data(fd) + offset, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p><code>file_write</code> is similar to its read brother.</p>
<details class="toggle"><summary class="toggle-button" style>file_write</summary><div class="toggle-content"><p>Generally, there is not much difference, but for write, we have to enlarge the file when necessary.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">file_write</span><span class="params">(<span class="keyword">struct</span> Fd* fd, <span class="type">const</span> <span class="type">void</span>* buf, u_int n, u_int offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span>* <span class="title">f</span> =</span> (<span class="keyword">struct</span> Filefd*)fd;</span><br><span class="line">    u_int tot = offset + n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t write more than the maximum file size.</span></span><br><span class="line">    <span class="keyword">if</span> (tot &gt; MAXFILESIZE)</span><br><span class="line">        <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increase the file&#x27;s size if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (tot &gt; f-&gt;f_file.f_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = ftruncate(fd2num(fd), tot)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the data</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">char</span>*)fd2data(fd) + offset, buf, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;   <span class="comment">// return bytes written</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fdnum, u_int size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAXFILESIZE)</span><br><span class="line">        <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span>* <span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd-&gt;fd_dev_id != devfile.dev_id)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span>* <span class="title">f</span> =</span> (<span class="keyword">struct</span> Filefd*)fd;</span><br><span class="line">    u_int fileid = f-&gt;f_fileid;</span><br><span class="line">    u_int oldsize = f-&gt;f_file.f_size;</span><br><span class="line">    f-&gt;f_file.f_size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = fsipc_set_size(fileid, size)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* va = fd2data(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map any new pages needed if extending the file</span></span><br><span class="line">    <span class="keyword">for</span> (u_int i = ROUND(oldsize, BY2PG); i &lt; ROUND(size, BY2PG); i += BY2PG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc_map(fileid, i, va + i)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fsipc_set_size(fileid, oldsize);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unmap pages if truncating the file</span></span><br><span class="line">    <span class="keyword">for</span> (u_int i = ROUND(size, BY2PG); i &lt; ROUND(oldsize, BY2PG); i += BY2PG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span>*)(va + i))) &lt; <span class="number">0</span>)</span><br><span class="line">            user_panic(<span class="string">&quot;ftruncate: syscall_mem_unmap %08x: %e&quot;</span>, va + i, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>When we close a file, we first should mark it dirty to save any changes back to the disk. Then, we just un-map its corresponding virtual address.</p>
<details class="toggle"><summary class="toggle-button" style>file_close</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_close</span><span class="params">(<span class="keyword">struct</span> Fd* fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span>* <span class="title">ffd</span> =</span> (<span class="keyword">struct</span> Filefd*)fd;</span><br><span class="line">    u_int fileid = ffd-&gt;f_fileid;</span><br><span class="line">    u_int size = ffd-&gt;f_file.f_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the start address storing the file&#x27;s content.</span></span><br><span class="line">    <span class="type">void</span>* va = fd2data(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the file server the dirty page.</span></span><br><span class="line">    <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; size; i += BY2PG)</span><br><span class="line">        fsipc_dirty(fileid, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request the file server to close the file with fsipc.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = fsipc_close(fileid)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        debugf(<span class="string">&quot;cannot close the file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unmap the content of file, release memory.</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; size; i += BY2PG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span>*)(va + i))) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            debugf(<span class="string">&quot;cannont unmap the file.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>Well, there’s not much to say about <code>file_stat</code>, it just get the statistics of a file.</p>
<details class="toggle"><summary class="toggle-button" style>file_stat</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">file_stat</span><span class="params">(<span class="keyword">struct</span> Fd* fd, <span class="keyword">struct</span> Stat* st)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span>* <span class="title">f</span> =</span> (<span class="keyword">struct</span> Filefd*)fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(st-&gt;st_name, f-&gt;f_file.f_name);</span><br><span class="line">    st-&gt;st_size = f-&gt;f_file.f_size;</span><br><span class="line">    st-&gt;st_isdir = f-&gt;f_file.f_type == FTYPE_DIR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h3 id="2-5-2-Library-Interface"><a href="#2-5-2-Library-Interface" class="headerlink" title="2.5.2 Library Interface"></a>2.5.2 Library Interface</h3><p>We cannot let users manipulate device directly, so we hide those details and provide some library interface for them. For the functions mentioned in <code>2.5.1</code>, we have corresponding library functions for each of them.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, u_int nbytes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, u_int nbytes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="keyword">struct</span> Stat* stat)</span>;</span><br></pre></td></tr></table></figure>

<details class="toggle"><summary class="toggle-button" style>close</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fdnum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span>* <span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span>* <span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    r = (*dev-&gt;dev_close)(fd);</span><br><span class="line">    fd_close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ℹ This is a little special, please refer to <a href="../File-System-IPC/">File System IPC</a> for more information. 😙</p>
</blockquote>
</div></details>

<details class="toggle"><summary class="toggle-button" style>read</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span>* buf, u_int n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span>* <span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span>* <span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd-&gt;fd_omode == O_WRONLY)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    r = dev-&gt;dev_read(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span>)</span><br><span class="line">        fd-&gt;fd_offset += r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read n bytes not at once</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span>* buf, u_int n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m, tot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tot = <span class="number">0</span>; tot &lt; n; tot += m)</span><br><span class="line">    &#123;</span><br><span class="line">        m = read(fdnum, (<span class="type">char</span>*)buf + tot, n - tot);</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<details class="toggle"><summary class="toggle-button" style>write</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">const</span> <span class="type">void</span>* buf, u_int n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span>* <span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span>* <span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_RDONLY)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    r = dev-&gt;dev_write(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span>)</span><br><span class="line">        fd-&gt;fd_offset += r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<details class="toggle"><summary class="toggle-button" style>stat</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="keyword">struct</span> Stat* stat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    r = fstat(fd, stat);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Stat* stat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span>* <span class="title">dev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span>* <span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span> || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stat-&gt;st_name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    stat-&gt;st_size = <span class="number">0</span>;</span><br><span class="line">    stat-&gt;st_isdir = <span class="number">0</span>;</span><br><span class="line">    stat-&gt;st_dev = dev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (*dev-&gt;dev_stat)(fd, stat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h3 id="2-5-3-Open-Close-a-File"><a href="#2-5-3-Open-Close-a-File" class="headerlink" title="2.5.3 Open &amp; Close a File"></a>2.5.3 Open &amp; Close a File</h3><p>Above is operations after we open a file. But, we have to open it first. So… ? 🫤 Let’s open it. The opening process can be divided into several steps.</p>
<ol>
<li>Allocate a page for file description. As stated above, we simple get a candidate virtual address and do nothing to it. So if we do this again, we’ll get the same virtual address.</li>
<li>Initialize the virtual address by requesting File System. File System will open the file and store the file descriptor in the virtual address we got in the first step. Of course, it will allocate a page to the address first. 🤪</li>
<li>Then, as we have the file descriptor allocate pages for the content of the file and map them to the 4 MB segment.</li>
<li>At last, return the file descriptor number to the caller.</li>
</ol>
<details class="toggle"><summary class="toggle-button" style>open</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Alloc a new &#x27;Fd&#x27; using &#x27;fd_alloc&#x27; in fd.c.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span>* <span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Prepare the &#x27;fd&#x27; using &#x27;fsipc_open&#x27; in fsipc.c.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: Set &#x27;va&#x27; to the address of the page where the &#x27;fd&#x27;&#x27;s data is cached.</span></span><br><span class="line">    <span class="type">char</span>* va = fd2data(fd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span>* <span class="title">ffd</span> =</span> (<span class="keyword">struct</span> Filefd*)fd;</span><br><span class="line">    u_int fileid = ffd-&gt;f_fileid;</span><br><span class="line">    u_int size = ffd-&gt;f_file.f_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4: Alloc pages and map the file content using &#x27;fsipc_map&#x27;.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc_map(fileid, i, va + i)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5: Return the number of file descriptor using &#x27;fd2num&#x27;.</span></span><br><span class="line">    <span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>Compared to opening a file, it would be much easier to close it.</p>
<details class="toggle"><summary class="toggle-button" style>close</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fdnum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span>* <span class="title">dev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span>* <span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span> || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = (*dev-&gt;dev_close)(fd);</span><br><span class="line">    fd_close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<hr>
<h1 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h1><p>A little verbose this time, I guess. 😵‍💫 But there are still some points that I didn’t cover… This is it… 😴 </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://tonys-studio.top">Tony Lewis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://blog.tonys-studio.top/posts/Lab-5-Reflection/">https://blog.tonys-studio.top/posts/Lab-5-Reflection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/BUAA/">BUAA</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/File-System-IPC/" title="File System IPC"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/ahsoka/04.jpeg" onerror="onerror=null;src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/404.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">File System IPC</div></div><div class="info-2"><div class="info-item-1">Brief on File System IPC Mechanism</div></div></div></a><a class="pagination-related" href="/posts/Getting-Started-with-Docker/" title="Getting Started With Docker"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/13/08.jpeg" onerror="onerror=null;src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/404.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Getting Started With Docker</div></div><div class="info-2"><div class="info-item-1">Brief introduction to Docker</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/File-System-IPC/" title="File System IPC"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/ahsoka/04.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> May. 6th, 2023 - 11:47:57</div><div class="info-item-2">File System IPC</div></div><div class="info-2"><div class="info-item-1">Brief on File System IPC Mechanism</div></div></div></a><a class="pagination-related" href="/posts/Lab-2-Extra-Reflection/" title="Lab 2 Extra Reflection"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/01/01.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Apr. 6th, 2023 - 19:53:06</div><div class="info-item-2">Lab 2 Extra Reflection</div></div><div class="info-2"><div class="info-item-1">Reflection on 2023 BUAA OS Lab 2 Extra</div></div></div></a><a class="pagination-related" href="/posts/Lab-4-Reflection/" title="Lab 4 Reflection"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/09/08.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Apr. 20th, 2023 - 17:07:01</div><div class="info-item-2">Lab 4 Reflection</div></div><div class="info-2"><div class="info-item-1">Reflection on 2023 BUAA OS Lab 4</div></div></div></a><a class="pagination-related" href="/posts/Lab-6-Challenge/" title="Lab 6 Challenge"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/boba/04/01.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jun. 18th, 2023 - 23:28:24</div><div class="info-item-2">Lab 6 Challenge</div></div><div class="info-2"><div class="info-item-1">Lab 6 Challenge - A More Powerful Shell</div></div></div></a><a class="pagination-related" href="/posts/Lab-6-Reflection/" title="Lab 6 Reflection"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/06/00.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jun. 18th, 2023 - 23:28:19</div><div class="info-item-2">Lab 6 Reflection</div></div><div class="info-2"><div class="info-item-1">Reflection on 2023 BUAA OS Lab 6 - Pipe & Shell</div></div></div></a><a class="pagination-related" href="/posts/Page-Directory-Self-Mapping/" title="Page Directory Self Mapping"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/13/07.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Mar. 25th, 2023 - 20:56:35</div><div class="info-item-2">Page Directory Self Mapping</div></div><div class="info-2"><div class="info-item-1">Understanding page directory self mapping</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/avatar/avatar.png" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/missing.gif'" alt="avatar"/></div><div class="author-info-name">Tony Lewis</div><div class="author-info-description">Do or do not. There is no try.</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">40</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Lord-Turmoil" target="_blank" title="Github"><i class="fa-brands fa-github"></i></a><a class="social-icon" href="mailto:swift-phantom@outlook.com" target="_blank" title="Email"><i class="fa-solid fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/2030942344" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">It won't be long before the armies of the Republic track us here.<br>You can visit this site at both:<li><a href="http://blog.tonys-studio.top/" target="_blank">Main Site</a></li><li><a href="https://lord-turmoil.github.io/" target="_blank">Github Mirror Site</a></li></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BUAA-2023-Spring-OS"><span class="toc-text">BUAA 2023 Spring OS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Prologue"><span class="toc-text">Prologue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tips-for-Windows-Players"><span class="toc-text">Tips for Windows Players</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Warning"><span class="toc-text">Warning</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Disk-Access"><span class="toc-text">1. Disk Access</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Device"><span class="toc-text">1.1 Device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Read-Write-Device-Segment"><span class="toc-text">1.2 Read &amp; Write Device Segment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-IDE-Read-Write"><span class="toc-text">1.3 IDE Read &amp; Write</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-IDE-Interface"><span class="toc-text">1.3.1 IDE Interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-IDE-Operation"><span class="toc-text">1.3.2 IDE Operation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-File-System"><span class="toc-text">2. File System</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Disk-Layout"><span class="toc-text">2.1 Disk Layout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Block-Cache-in-Memory"><span class="toc-text">2.2 Block Cache in Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Block-Management"><span class="toc-text">2.3 Block Management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Block-Initialization"><span class="toc-text">2.3.1 Block Initialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-Block-Mapping"><span class="toc-text">2.3.2 Block Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-Block-Allocation"><span class="toc-text">2.3.3 Block Allocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-Read-Write-Block"><span class="toc-text">2.3.4 Read &amp; Write Block</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-File-Layout"><span class="toc-text">2.4 File Layout</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-File-Block"><span class="toc-text">2.4.1 File &amp; Block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-File-Descriptor"><span class="toc-text">2.4.2 File Descriptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-Allocate-Free-File-Descriptor"><span class="toc-text">2.4.3 Allocate &amp; Free File Descriptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-Traverse-File-Blocks"><span class="toc-text">2.4.4 Traverse File Blocks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-File-Operations"><span class="toc-text">2.5 File Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-Device-Interface"><span class="toc-text">2.5.1 Device Interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-Library-Interface"><span class="toc-text">2.5.2 Library Interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-Open-Close-a-File"><span class="toc-text">2.5.3 Open &amp; Close a File</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Epilogue"><span class="toc-text">Epilogue</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/22/12.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/404.png'" alt="Getting Started With Coq"/></a><div class="content"><a class="title" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq">Getting Started With Coq</a><time datetime="2025-08-08T04:30:12.000Z" title="Created Aug. 8th, 2025 - 12:30:12 12:30:12">Aug. 8th, 2025 - 12:30:12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/" title="Game Engine 0 to 1 (02): Something on the Screen"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/13/09.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/404.png'" alt="Game Engine 0 to 1 (02): Something on the Screen"/></a><div class="content"><a class="title" href="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/" title="Game Engine 0 to 1 (02): Something on the Screen">Game Engine 0 to 1 (02): Something on the Screen</a><time datetime="2025-07-04T12:07:57.000Z" title="Created Jul. 4th, 2025 - 20:07:57 20:07:57">Jul. 4th, 2025 - 20:07:57</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/boba/05/11.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/404.png'" alt="Game Engine 0 to 1 (01): It Starts Now"/></a><div class="content"><a class="title" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now">Game Engine 0 to 1 (01): It Starts Now</a><time datetime="2025-06-01T06:45:32.000Z" title="Created Jun. 1st, 2025 - 14:45:32 14:45:32">Jun. 1st, 2025 - 14:45:32</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Game-Engine-0-to-1-00-Nothing-s-Here/" title="Game Engine 0 to 1 (00): Nothing's Here"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/ahsoka/00.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/404.png'" alt="Game Engine 0 to 1 (00): Nothing's Here"/></a><div class="content"><a class="title" href="/posts/Game-Engine-0-to-1-00-Nothing-s-Here/" title="Game Engine 0 to 1 (00): Nothing's Here">Game Engine 0 to 1 (00): Nothing's Here</a><time datetime="2025-05-27T11:05:29.000Z" title="Created May. 27th, 2025 - 19:05:29 19:05:29">May. 27th, 2025 - 19:05:29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Demystifying-NAT-in-P2P/" title="Demystifying NAT in P2P"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/02/05.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/404.png'" alt="Demystifying NAT in P2P"/></a><div class="content"><a class="title" href="/posts/Demystifying-NAT-in-P2P/" title="Demystifying NAT in P2P">Demystifying NAT in P2P</a><time datetime="2025-04-25T08:36:44.000Z" title="Created Apr. 25th, 2025 - 16:36:44 16:36:44">Apr. 25th, 2025 - 16:36:44</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/img/banner/mando/14/09.jpeg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By Tony Lewis</span></div><div class="footer_custom_text">No bird soars too high if he soars on his own wings</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'forest'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://comment.tonys-studio.top',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client@2/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client@2/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/custom.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Anything you would like to search?🔍" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="Framework Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="Theme Butterfly" title=""><img src="https://img.shields.io/badge/Theme-Butterfly%205.3.3-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="All articles in this blog are licensed under CC BY-NC-SA 4.0 unless stating additionally." title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><!-- hexo injector body_end end --></body></html>