<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Lab 4 Reflection | TONY'S STUDIO</title><meta name="author" content="Tony Lewis"><meta name="copyright" content="Tony Lewis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#300303"><meta name="description" content="Reflection on 2023 BUAA OS Lab 4">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab 4 Reflection">
<meta property="og:url" content="https://blog.tonys-studio.top/posts/Lab-4-Reflection/">
<meta property="og:site_name" content="TONY&#39;S STUDIO">
<meta property="og:description" content="Reflection on 2023 BUAA OS Lab 4">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/02/03.jpeg">
<meta property="article:published_time" content="2023-04-20T09:07:01.000Z">
<meta property="article:modified_time" content="2025-09-16T10:21:43.788Z">
<meta property="article:author" content="Tony Lewis">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="BUAA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/02/03.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Lab 4 Reflection",
  "url": "https://blog.tonys-studio.top/posts/Lab-4-Reflection/",
  "image": "https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/02/03.jpeg",
  "datePublished": "2023-04-20T09:07:01.000Z",
  "dateModified": "2025-09-16T10:21:43.788Z",
  "author": [
    {
      "@type": "Person",
      "name": "Tony Lewis",
      "url": "https://tonys-studio.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/favicon.svg"><link rel="canonical" href="https://blog.tonys-studio.top/posts/Lab-4-Reflection/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-R6O16YoeQt"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#300303')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?68629f5da0a0c3347b896920fbf164b5";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "sthrplbt7c");
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":10,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":256,"languages":{"author":"Author: Tony Lewis","link":"Link: ","source":"Source: TONY'S STUDIO","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#871798","bgDark":"#C81025","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lab 4 Reflection',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/static/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-footer-beautify@1.0.6/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/css/barber-shop.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/avatar.png" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/missing.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">94</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">41</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-jedi fa-beat"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/02/03.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/logo.svg" alt="Logo"><span class="site-name">TONY'S STUDIO</span></a><a class="nav-page-title" href="/"><span class="site-name">Lab 4 Reflection</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-jedi fa-beat"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Lab 4 Reflection</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-20T09:07:01.000Z" title="Created Apr. 20th, 2023 - 17:07:01 17:07:01">Apr. 20th, 2023 - 17:07:01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-09-16T10:21:43.788Z" title="Updated Sep. 16th, 2025 - 18:21:43 18:21:43">Sep. 16th, 2025 - 18:21:43</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA/">BUAA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA/OS/">OS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>34mins</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span class="waline-pageview-count" data-path="/posts/Lab-4-Reflection/"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/posts/Lab-4-Reflection/#post-comment"><span class="waline-comment-count" data-path="/posts/Lab-4-Reflection/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="BUAA-2023-Spring-OS"><a href="#BUAA-2023-Spring-OS" class="headerlink" title="BUAA 2023 Spring OS"></a>BUAA 2023 Spring OS</h1><hr>
<h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>In this lab, we’ll have a glance at system call for the first time.</p>
<hr>
<h1 id="A-“Call”-to-Answer"><a href="#A-“Call”-to-Answer" class="headerlink" title="A “Call” to Answer"></a>A “Call” to Answer</h1><p>For security reasons, certain instructions could not be accessed by user process. However, user process still need to complete certain tasks. Therefore, we have to “call” kernel to do that for us. And we, again, as “kernel”, have to answer such a “call”.</p>
<blockquote>
<p> Well, this process is easy to understand since… PassBash also uses this pattern.</p>
</blockquote>
<h2 id="User-Call"><a href="#User-Call" class="headerlink" title="User Call"></a>User Call</h2><p>As user, we got a “phone book” to look for functions to call. And this phone book is <code>user/lib/syscall_lib.c</code>. We can see a lot of functions with prefix <code>syscall_</code>, indicating a system  call. When we want a service, we can just call specific system call.</p>
<p>But, how can we really call kernel? Well, we do this by executing <code>syscall</code> instruction. By calling this, we’ll sink into kernel immediately, thus make kernel answer. To make this simpler, we wrap system call into one unified interface, which is the so called <code>msyscall</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An example system call for user.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_putchar</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    msyscall(SYS_putchar, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And for <code>msyscall</code>, we just do <code>syscall</code> to sink into kernel.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LEAF(msyscall)</span><br><span class="line">    syscall</span><br><span class="line">    j ra</span><br><span class="line">END(msyscall)</span><br></pre></td></tr></table></figure>

<h2 id="Kernel-Answer"><a href="#Kernel-Answer" class="headerlink" title="Kernel Answer"></a>Kernel Answer</h2><p>When user calls, we kernel will answer. <code>syscall</code> actually invoke exception No.8 - <code>handle_sys</code>, so our answer starts from this specific function. However, before we actually get into exception handler, we first jump to exception entry, which is a fixed address for MIPS. We set exception entry point in <code>kernel.lds</code>, and exception handler entry function will be loaded here.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># kernel.lds</span><br><span class="line">SECTIONS &#123;</span><br><span class="line">    # ...</span><br><span class="line">    . = 0x80000080;</span><br><span class="line">    .exc_gen_entry : &#123; *(.text.exc_gen_entry) &#125;</span><br><span class="line">    # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This will be executed every time there is an exception.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># kern/entry.S</span><br><span class="line">.section .text.exc_gen_entry</span><br><span class="line">exc_gen_entry:</span><br><span class="line">    SAVE_ALL  # save all registers to Trapframe</span><br><span class="line">    mfc0 t0, CP0_CAUSE</span><br><span class="line">    andi t0, 0x7c</span><br><span class="line">    lw t0, exception_handlers(t0)  # call exception handler</span><br><span class="line">    jr t0</span><br></pre></td></tr></table></figure>

<p>So, what is <code>exception_handler</code>? We defined this previously <code>kern/traps.c</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*exception_handlers[<span class="number">32</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    [<span class="number">0</span> ... <span class="number">31</span>] = handle_reserved,</span><br><span class="line">    [<span class="number">0</span>] = handle_int,</span><br><span class="line">    [<span class="number">2</span> ... <span class="number">3</span>] = handle_tlb,</span><br><span class="line">    [<span class="number">1</span>] = handle_mod,</span><br><span class="line">    [<span class="number">8</span>] = handle_sys,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>So we just jump to these specific handlers to handle our exceptions. You may notice that <code>CP0.Cause</code> register is used to get the handlers, so what is it?</p>
<p><img src="/posts/Lab-4-Reflection/image-20230420204633657.png" alt="image-20230420204633657"></p>
<p>We can see that, by <code>andi t0, 0x7c</code>, we get the <code>ExcCode</code> bits in it, which indicates the type of exception to handle.</p>
<blockquote>
<p>Notice that, for <code>exception_handlers(t0)</code>, <code>t0</code> is not a index in C. Instead, it is a raw offset! So the lowest 2 bits are zero to make it byte aligned.</p>
</blockquote>
<h2 id="Exception-Handler"><a href="#Exception-Handler" class="headerlink" title="Exception Handler"></a>Exception Handler</h2><p>Now that we can jump to exception handlers, let’s have a closer look at them, for example <code>handle_sys</code> here. It is declared using a macro. The actual function is <code>do_syscall</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kern/genex.S</span><br><span class="line">BUILD_HANDLER sys do_syscall</span><br></pre></td></tr></table></figure>

<p>And then the declaration for <code>do_syscall</code> in <code>kern/syscall_all.c</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe* tf)</span>;</span><br></pre></td></tr></table></figure>

<p>Since all registers (including <code>pc</code>, <code>sp</code>, etc.) will be saved when exception is triggered, we can get the parameters user passed to us from corresponding <code>Trapframe</code>. More specifically, one register for handler type, and five for  actual parameters. For type, we also have a table in kernel for handlers in <code>kern/syscall_all.c</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* syscall_table[MAX_SYSNO] = &#123;</span><br><span class="line">    [SYS_putchar] = sys_putchar,</span><br><span class="line">    [SYS_exofork] = sys_exofork,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Register <code>$a0</code> indicates the type of the call, and <code>$a1</code> to <code>$a3</code> and the other 2 in stack are the real parameters. Then, we can get the correct handler for the call and pass parameters to it.</p>
<blockquote>
<p>In fact, user could passed at most 6 parameters to system call. However, the first one is the type of call, rather than a valid parameter.</p>
</blockquote>
<p>After handling, we set <code>$v0</code> (<code>$2</code>) to the return value of system call, to send it back to user.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5);</span><br></pre></td></tr></table></figure>

<p>Here is the complete code for <code>do_syscall</code>.</p>
<details class="toggle"><summary class="toggle-button" style>do_syscall</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Call the function in &#x27;syscall_table&#x27; indexed at &#x27;sysno&#x27; with arguments from</span></span><br><span class="line"><span class="comment"> * user context and stack.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint:</span></span><br><span class="line"><span class="comment"> *   Use sysno from $a0 to dispatch the syscall.</span></span><br><span class="line"><span class="comment"> *   The possible arguments are stored at $a1, $a2, $a3, [$sp + 16 bytes],</span></span><br><span class="line"><span class="comment"> * [$sp + 20 bytes] in order.</span></span><br><span class="line"><span class="comment"> *   Number of arguments cannot exceed 5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe* tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int); <span class="comment">// handler</span></span><br><span class="line">    <span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];  <span class="comment">// $a0</span></span><br><span class="line">    <span class="keyword">if</span> (sysno &lt; <span class="number">0</span> || sysno &gt;= MAX_SYSNO)</span><br><span class="line">    &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Add the EPC in &#x27;tf&#x27; by a word (size of an instruction). */</span></span><br><span class="line">    tf-&gt;cp0_epc += <span class="number">4</span>;	<span class="comment">// to skip syscall instruction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Use &#x27;sysno&#x27; to get &#x27;func&#x27; from &#x27;syscall_table&#x27;. */</span></span><br><span class="line">    func = syscall_table[sysno];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: First 3 args are stored in $a1, $a2, $a3. */</span></span><br><span class="line">    u_int arg1 = tf-&gt;regs[<span class="number">5</span>];</span><br><span class="line">    u_int arg2 = tf-&gt;regs[<span class="number">6</span>];</span><br><span class="line">    u_int arg3 = tf-&gt;regs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Last 2 args are stored in stack at [$sp + 16 bytes], [$sp + 20 bytes]. */</span></span><br><span class="line">    u_int arg4, arg5;</span><br><span class="line">    arg4 = *(u_int*)(tf-&gt;regs[<span class="number">29</span>] + <span class="number">16</span>);	<span class="comment">// $sp is $29</span></span><br><span class="line">    arg5 = *(u_int*)(tf-&gt;regs[<span class="number">29</span>] + <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step 5: Invoke &#x27;func&#x27; with retrieved arguments and store its return value</span></span><br><span class="line"><span class="comment">     * to $v0 in &#x27;tf&#x27;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<blockquote>
<p>Notice that, for user, system call starts with <code>syscall_</code>, it at last calls the real system call in kernel mode, which starts with <code>sys_</code>.</p>
</blockquote>
<hr>
<h1 id="Basic-System-Calls"><a href="#Basic-System-Calls" class="headerlink" title="Basic System Calls"></a>Basic System Calls</h1><p>Before we get into some fancy system calls, lets have a look at some fundamental ones. They all located in <code>kern/syscall_all.c</code>.</p>
<h2 id="Identify-Process"><a href="#Identify-Process" class="headerlink" title="Identify Process"></a>Identify Process</h2><p>To know which process to manipulate, we use process id, which, in MOS, is <code>Env::env_id</code>. We simply get a <code>Env</code> from a <code>envid</code> via <code>envid2env</code> function. Its located in <code>kern/env.c</code>. If <code>checkperm</code> is set, we can only get <code>Env</code> that with certain permissions (relation with current env).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">envid2env</span><span class="params">(u_int envid, <span class="keyword">struct</span> Env** penv, <span class="type">int</span> checkperm)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Notice that, if <code>envid</code> is zero, then this function will degenerate into getting current Env only!</p>
<p>By the way, this is why <code>Env::env_id</code> won’t be zero, since zero indicate current Env.</p>
</blockquote>
<p>Here is the complete definition of it.</p>
<details class="toggle"><summary class="toggle-button" style>envid2env</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Convert an existing &#x27;envid&#x27; to an &#x27;struct Env *&#x27;.</span></span><br><span class="line"><span class="comment"> *   If &#x27;envid&#x27; is 0, set &#x27;*penv = curenv&#x27;, otherwise set &#x27;*penv = &amp;envs[ENVX(envid)]&#x27;.</span></span><br><span class="line"><span class="comment"> *   In addition, if &#x27;checkperm&#x27; is non-zero, the requested env must be either</span></span><br><span class="line"><span class="comment"> * &#x27;curenv&#x27; or its immediate child.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> *   &#x27;penv&#x27; points to a valid &#x27;struct Env *&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   return 0 on success, and set &#x27;*penv&#x27; to the env.</span></span><br><span class="line"><span class="comment"> *   return -E_BAD_ENV on error (invalid &#x27;envid&#x27; or &#x27;checkperm&#x27; violated).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">envid2env</span><span class="params">(u_int envid, <span class="keyword">struct</span> Env** penv, <span class="type">int</span> checkperm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Assign value to &#x27;e&#x27; using &#x27;envid&#x27;. */</span></span><br><span class="line">    <span class="keyword">if</span> (envid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If envid is zero, this function will degenerate to get current</span></span><br><span class="line"><span class="comment">        * env only. If not, envid is bound to be different from e-&gt;env_id, since</span></span><br><span class="line"><span class="comment">        * e-&gt;envid won&#x27;t be zero. Hence, we must return here.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        *penv = curenv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        e = &amp;envs[ENVX(envid)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Check when &#x27;checkperm&#x27; is non-zero. */</span></span><br><span class="line">    <span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment">     *   Check whether the calling env has sufficient permissions to manipulate</span></span><br><span class="line"><span class="comment">     * the specified env, i.e. &#x27;e&#x27; is either &#x27;curenv&#x27; or its immediate child.</span></span><br><span class="line"><span class="comment">     *   If violated, return &#x27;-E_BAD_ENV&#x27;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (checkperm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((e-&gt;env_id == curenv-&gt;env_id) || (e-&gt;env_parent_id == curenv-&gt;env_id)))</span><br><span class="line">            <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Assign &#x27;e&#x27; to &#x27;*penv&#x27;. */</span></span><br><span class="line">    *penv = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>For this line, we check <code>e-&gt;env_id</code> and <code>envid</code>, but why, we already get one?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid)</span><br></pre></td></tr></table></figure>

<p>We have 1024 Envs, and the low 10 bits are to present the physical offset of a env to the base address <code>envs</code>. If ew have more than 1024 Envs, the high 22 bits are to ensure uniqueness of Env.</p>
<p>Here, we get <code>e</code> by the lowest 10 bits from <code>envid</code> and ignores the high bits, thus make two different Envs with the same low 10 bits possible. This is perhaps because of getting a out of data Env, or simply a bad envid.</p>
</blockquote>
</div></details>

<h2 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h2><p>Memory management is important to kernel, there’s no doubt.</p>
<h3 id="sys-mem-alloc"><a href="#sys-mem-alloc" class="headerlink" title="sys_mem_alloc"></a><code>sys_mem_alloc</code></h3><p>Well, just like <code>malloc</code>, this function requires kernel to allocate a physical page, to make access at given virtual address legal.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span>;</span><br></pre></td></tr></table></figure>

<p>There’s not much thing to say about this one. It just allocate a new page, and use <code>page_insert</code> to map it to the given <code>va</code>. Though trivial, previous page that mapped to <code>va</code> will be unmapped. (see <code>page_insert</code>)</p>
<details class="toggle"><summary class="toggle-button" style>sys_mem_alloc</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Allocate a physical page and map &#x27;va&#x27; to it with &#x27;perm&#x27; in the address space</span></span><br><span class="line"><span class="comment"> *   of &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment"> *   If &#x27;va&#x27; is already mapped, that original page is silently unmapped.</span></span><br><span class="line"><span class="comment"> *   &#x27;envid2env&#x27; should be used with &#x27;checkperm&#x27; set, like in most syscalls, to</span></span><br><span class="line"><span class="comment"> *   ensure the target is either the caller or its child.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 on success.</span></span><br><span class="line"><span class="comment"> *   Return -E_BAD_ENV: &#x27;checkperm&#x27; of &#x27;envid2env&#x27; fails for &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment"> *   Return -E_INVAL:   &#x27;va&#x27; is illegal (should be checked using &#x27;is_illegal_va&#x27;).</span></span><br><span class="line"><span class="comment"> *   Return the original error: underlying calls fail (you can use &#x27;try&#x27; macro).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint:</span></span><br><span class="line"><span class="comment"> *   You may want to use the following functions:</span></span><br><span class="line"><span class="comment"> *   &#x27;envid2env&#x27;, &#x27;page_alloc&#x27;, &#x27;page_insert&#x27;, &#x27;try&#x27; (macro)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Check if &#x27;va&#x27; is a legal user virtual address using &#x27;is_illegal_va&#x27;. */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Convert the envid to its corresponding &#x27;struct Env *&#x27;</span></span><br><span class="line"><span class="comment">       using &#x27;envid2env&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Hint: **Always** validate the permission in syscalls! */</span></span><br><span class="line">    try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Allocate a physical page using &#x27;page_alloc&#x27;. */</span></span><br><span class="line">    try(page_alloc(&amp;pp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Map the allocated page at &#x27;va&#x27; with permission &#x27;perm&#x27; using &#x27;page_insert&#x27;. */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, pp, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You may be curious about <code>is_illegal_va</code>, it just check if <code>va</code> is within user’s space or not.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">is_illegal_va</span><span class="params">(u_long va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> va &lt; UTEMP || va &gt;= UTOP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<blockquote>
<p><strong>Breaking News!</strong> Understanding of how <code>page_insert</code> works. Basically, it just fill the address field of the page table entry for <code>va</code> with the physical page number of the page. Thus we can use the physical memory though this <code>va</code>. It can be divided into two steps.</p>
<ol>
<li>First, it ensures page table entry for <code>va</code> exists. If such entry exists, but not mapped to the given page, it will remove the page. If mapped to, it will flush TLB and reset permission. If doesn’t exist, it will create one.</li>
<li>Then, it fills the page table entry with the physical address of the page.</li>
</ol>
<p><strong>Important!</strong> When we talk about mapping or un-mapping a page to virtual memory, we simply fill or clear the page table entry of the given virtual memory.</p>
<p><strong>Again!</strong> <code>page_insert</code> <strong>does not</strong> create new page! It only add the physical address of the given page to a specific page table entry. The same as <code>page_remove</code>.</p>
<p>For a more detailed understanding of virtual memory and page table entry, you can refer to my previous post here: <a href="/posts/Page-Directory-Self-Mapping/">Page Directory Self Mapping</a>.</p>
</blockquote>
<h3 id="sys-mem-map"><a href="#sys-mem-map" class="headerlink" title="sys_mem_map"></a><code>sys_mem_map</code></h3><p>This is a tricky function. What it does is mapping the physical memory, that mapped to source Env with id <code>srcid</code> at virtual address <code>srcva</code> to the destination Env with id <code>dstid</code> at virtual address <code>dstva</code>. That is to say, make these two Env share a same page.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span>;</span><br></pre></td></tr></table></figure>

<details class="toggle"><summary class="toggle-button" style>sys_mem_map</summary><div class="toggle-content"><p>Here is the realization of it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Find the physical page mapped at &#x27;srcva&#x27; in the address space of env &#x27;srcid&#x27;,</span></span><br><span class="line"><span class="comment"> * and map &#x27;dstid&#x27;&#x27;s &#x27;dstva&#x27; to it with &#x27;perm&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 on success.</span></span><br><span class="line"><span class="comment"> *   Return -E_BAD_ENV: &#x27;checkperm&#x27; of &#x27;envid2env&#x27; fails for &#x27;srcid&#x27; or &#x27;dstid&#x27;.</span></span><br><span class="line"><span class="comment"> *   Return -E_INVAL: &#x27;srcva&#x27; or &#x27;dstva&#x27; is illegal, or &#x27;srcva&#x27; is unmapped in &#x27;srcid&#x27;.</span></span><br><span class="line"><span class="comment"> *   Return the original error: underlying calls fail.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint:</span></span><br><span class="line"><span class="comment"> *   You may want to use the following functions:</span></span><br><span class="line"><span class="comment"> *   &#x27;envid2env&#x27;, &#x27;page_lookup&#x27;, &#x27;page_insert&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step 1: Check if &#x27;srcva&#x27; and &#x27;dstva&#x27; are legal user virtual addresses using</span></span><br><span class="line"><span class="comment">     * &#x27;is_illegal_va&#x27;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(srcva) || is_illegal_va(dstva))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">srcenv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">dstenv</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Step 2: Convert the &#x27;srcid&#x27; to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">    try(envid2env(srcid, &amp;srcenv, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Convert the &#x27;dstid&#x27; to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">    try(envid2env(dstid, &amp;dstenv, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Find the physical page mapped at &#x27;srcva&#x27; in the address space of &#x27;srcid&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not mapped. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">pp</span> =</span> page_lookup(srcenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pp)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: Map the physical page at &#x27;dstva&#x27; in the address space of &#x27;dstid&#x27;. */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(dstenv-&gt;env_pgdir, dstenv-&gt;env_asid, pp, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h3 id="sys-mem-unmap"><a href="#sys-mem-unmap" class="headerlink" title="sys_mem_unmap"></a><code>sys_mem_unmap</code></h3><p>Well, <code>sys_mem_unmap</code> is similar to its map brother. Just un-map the physical address of given virtual memory, making it no longer valid to access.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_unmap</span><span class="params">(u_int envid, u_int va)</span>;</span><br></pre></td></tr></table></figure>

<details class="toggle"><summary class="toggle-button" style>sys_mem_unmap</summary><div class="toggle-content"><p>Just, quite simple.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Unmap the physical page mapped at &#x27;va&#x27; in the address space of &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment"> *   If no physical page is mapped there, this function silently succeeds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 on success.</span></span><br><span class="line"><span class="comment"> *   Return -E_BAD_ENV: &#x27;checkperm&#x27; of &#x27;envid2env&#x27; fails for &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment"> *   Return -E_INVAL:   &#x27;va&#x27; is illegal.</span></span><br><span class="line"><span class="comment"> *   Return the original error when underlying calls fail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_unmap</span><span class="params">(u_int envid, u_int va)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Check if &#x27;va&#x27; is a legal user virtual address using &#x27;is_illegal_va&#x27;. */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Convert the envid to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">    try(envid2env(envid, &amp;e, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Unmap the physical page at &#x27;va&#x27; in the address space of &#x27;envid&#x27;. */</span></span><br><span class="line">    page_remove(e-&gt;env_pgdir, e-&gt;env_asid, va);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h2 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h2><p>Schedule is also an important part of OS. And yield is to give up possession of CPU, due to inability to continue, or some other reasons. It is simple, just make kernel schedule again is OK.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Give up remaining CPU time slice for &#x27;curenv&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Another env is scheduled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint:</span></span><br><span class="line"><span class="comment"> *   This function will never return.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) sys_yield(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Hint: Just use &#x27;schedule&#x27; with &#x27;yield&#x27; set.</span></span><br><span class="line">    schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Notice that it will not return, since <code>schedule</code> is a no-return.</p>
</blockquote>
<hr>
<h1 id="Inter-Process-Communication"><a href="#Inter-Process-Communication" class="headerlink" title="Inter-Process Communication"></a>Inter-Process Communication</h1><p>Well, IPC, huh? The fundamental support of IPC lies within Env, so let’s have a look.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ... other members</span></span><br><span class="line">    u_int env_ipc_value;   <span class="comment">// data value sent to us</span></span><br><span class="line">    u_int env_ipc_from;    <span class="comment">// envid of the sender</span></span><br><span class="line">    u_int env_ipc_recving; <span class="comment">// env receiving status (block 0 or accept 1)</span></span><br><span class="line">    u_int env_ipc_dstva;   <span class="comment">// va at which to map received page</span></span><br><span class="line">    u_int env_ipc_perm;    <span class="comment">// perm of page mapping received</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As receiver, we can decide whether to receive message or not. e.g. We can set <code>Env::env_ipc_receiving</code> to 1, which indicate that we are receiving message, or 0 to block any message, and make sender’s sending request fail. Plus, we need <code>Env::env_ipc_from</code> to know the source of the message.</p>
<p>If we only send a value, we only need <code>Env::env_ipc_value</code>, and set <code>Env::env_ipc_dstva</code> to 0. Otherwise, a valid virtual address is required.</p>
<p>As sender, we can set the receiver’s <code>Env::env_ipc_value</code> and <code>Env::env_ipc_from</code>, and, if there is, map message page to <code>Env::env_ipc_dstva</code>.</p>
<p>Now, let’s see some core functions of IPC.</p>
<h2 id="sys-ipc-recv"><a href="#sys-ipc-recv" class="headerlink" title="sys_ipc_recv"></a><code>sys_ipc_recv</code></h2><p>This system call make current process starts to receive a message. Such action will block current process from continue, until it receives the desired message. Here is its declaration.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_recv</span><span class="params">(u_int dstva)</span>;</span><br></pre></td></tr></table></figure>

<p>The caller of this system call is current process. If we only want to receive a value, we simply set <code>dstva</code> to 0. Otherwise, we should set it to our desired virtual address. Then, since the process will be blocked, we’ll set its status to <code>ENV_NOT_RUNNABLE</code> and remove it from <code>env_sched_list</code>. At last, we should set the default return value 0 to <code>$v0</code>.</p>
<details class="toggle"><summary class="toggle-button" style>sys_ipc_recv</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Wait for a message (a value, together with a page if &#x27;dstva&#x27; is not 0) from</span></span><br><span class="line"><span class="comment"> *   other envs.</span></span><br><span class="line"><span class="comment"> *   &#x27;curenv&#x27; is blocked until a message is sent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 on success.</span></span><br><span class="line"><span class="comment"> *   Return -E_INVAL: &#x27;dstva&#x27; is neither 0 nor a legal address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_recv</span><span class="params">(u_int dstva)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Step 1: Check if &#x27;dstva&#x27; is either zero or a legal address. */</span></span><br><span class="line">    <span class="keyword">if</span> ((dstva != <span class="number">0</span>) &amp;&amp; is_illegal_va(dstva))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Set &#x27;curenv-&gt;env_ipc_recving&#x27; to 1. */</span></span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Set the value of &#x27;curenv-&gt;env_ipc_dstva&#x27;. */</span></span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step 4: Set the status of &#x27;curenv&#x27; to &#x27;ENV_NOT_RUNNABLE&#x27; and remove it from</span></span><br><span class="line"><span class="comment">     * &#x27;env_sched_list&#x27;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    TAILQ_REMOVE(&amp;env_sched_list, curenv, env_sched_link);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: Give up the CPU and block until a message is received. */</span></span><br><span class="line">    ((<span class="keyword">struct</span> Trapframe*)KSTACKTOP - <span class="number">1</span>)-&gt;regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    schedule(<span class="number">1</span>);  <span class="comment">// with yeild set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<h2 id="sys-ipc-try-send"><a href="#sys-ipc-try-send" class="headerlink" title="sys_ipc_try_send"></a><code>sys_ipc_try_send</code></h2><p>He’s waiting for us! Let’s send him a message! It is quite straightforward, with all parameters receiver need. Notice that here we use ‘try’ send, because we may fail to send due to target process is not receiving or other errors.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_send</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span>;</span><br></pre></td></tr></table></figure>

<p>Since the receiver was suspended because of waiting for message, we need to wake him up after we send the message. If we also send a page, we should map our page to <code>Env::env_ipc_dstva</code> of our receiver using <code>page_insert</code>. And set its <code>Env::env_ipc_recving</code> 0 to mark completion.</p>
<blockquote>
<p>The same with <code>page_insert</code>, we only link sender’s page to receiver’s page table entry. Only.</p>
</blockquote>
<p>One more thing, in this system call, we <strong>do not</strong> restrict permission in <code>envid2env</code>, since message can be exchanged between processes with no relations.</p>
<details class="toggle"><summary class="toggle-button" style>sys_ipc_try_send</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Try to send a &#x27;value&#x27; (together with a page if &#x27;srcva&#x27; is not 0) to the target</span></span><br><span class="line"><span class="comment"> * env &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 on success, and the target env is updated as follows:</span></span><br><span class="line"><span class="comment"> *   - &#x27;env_ipc_recving&#x27; is set to 0 to block future sends.</span></span><br><span class="line"><span class="comment"> *   - &#x27;env_ipc_from&#x27; is set to the sender&#x27;s envid.</span></span><br><span class="line"><span class="comment"> *   - &#x27;env_ipc_value&#x27; is set to the &#x27;value&#x27;.</span></span><br><span class="line"><span class="comment"> *   - &#x27;env_status&#x27; is set to &#x27;ENV_RUNNABLE&#x27; again to recover from &#x27;ipc_recv&#x27;.</span></span><br><span class="line"><span class="comment"> *   - if &#x27;srcva&#x27; is not NULL, map &#x27;env_ipc_dstva&#x27; to the same page mapped at &#x27;srcva&#x27; in &#x27;curenv&#x27;</span></span><br><span class="line"><span class="comment"> *     with &#x27;perm&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Return -E_IPC_NOT_RECV if the target has not been waiting for an IPC message with</span></span><br><span class="line"><span class="comment"> *   &#x27;sys_ipc_recv&#x27;.</span></span><br><span class="line"><span class="comment"> *   Return the original error when underlying calls fail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_send</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Step 1: Check if &#x27;srcva&#x27; is either zero or a legal address. */</span></span><br><span class="line">    <span class="keyword">if</span> ((srcva != <span class="number">0</span>) &amp;&amp; is_illegal_va(srcva))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Step 2: Convert &#x27;envid&#x27; to &#x27;struct Env *e&#x27;. */</span></span><br><span class="line">    <span class="comment">/* This is the only syscall where the &#x27;envid2env&#x27; should be used with &#x27;checkperm&#x27; UNSET,</span></span><br><span class="line"><span class="comment">     * because the target env is not restricted to &#x27;curenv&#x27;&#x27;s children. */</span></span><br><span class="line">    try(envid2env(envid, &amp;e, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Check if the target is waiting for a message. */</span></span><br><span class="line">    <span class="keyword">if</span> (!e-&gt;env_ipc_recving)</span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Set the target&#x27;s ipc fields. */</span></span><br><span class="line">    e-&gt;env_ipc_value = value;</span><br><span class="line">    e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    e-&gt;env_ipc_perm = PTE_V | perm;</span><br><span class="line">    e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: Set the target&#x27;s status to &#x27;ENV_RUNNABLE&#x27; again and insert it to</span></span><br><span class="line"><span class="comment">     * the tail of &#x27;env_sched_list&#x27;. */</span></span><br><span class="line">    e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 6: If &#x27;srcva&#x27; is not zero, map the page at &#x27;srcva&#x27; in &#x27;curenv&#x27; to</span></span><br><span class="line"><span class="comment">     * &#x27;e-&gt;env_ipc_dstva&#x27; in &#x27;e&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not zero and not mapped in &#x27;curenv&#x27;. */</span></span><br><span class="line">    <span class="keyword">if</span> (srcva != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = page_lookup(curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Though we didn&#x27;t check if receiver accepts page or not, we can still </span></span><br><span class="line"><span class="comment">         * check it indirectly by `page_insert` since this functino will return </span></span><br><span class="line"><span class="comment">         * error in that case.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You may wonder, what if receiver’s <code>Env::env_ipc_dstva</code> is 0, and it is a valid virtual address? Haha, don’t worry, you can check <code>include/mmu.h</code>, address from <code>0x0</code> to <code>UTEMP</code>, which is larger than one page, is invalid memory. :P</p>
</div></details>

<hr>
<h1 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h1><p>As we know before, fork is a useful function to duplicate process. It is fascinating, as we’ve been curious about its realization long before when we first encountered it here <a href="/posts/Process/">Process</a>. You could use this as application of fork first.</p>
<p>In this part, I’d like to demonstrate stuffs from top to bottom. :)</p>
<h2 id="Fork-in-Kernel-Space"><a href="#Fork-in-Kernel-Space" class="headerlink" title="Fork in Kernel Space"></a>Fork in Kernel Space</h2><p>Well, fork is actually a lib function in user space, and the core of it is a system call named <code>syscall_exofork</code>, which eventually calls <code>sys_exofork</code>, and this system call explains how we get a new process out of nowhere. Now, let’s have a look of it. It’s surprisingly not that long, but each line has its meaning.</p>
<p>First, it’s declaration. Err… really simple.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>First, we really create a PCB (Env) from nowhere.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 1: Allocate a new env using &#x27;env_alloc&#x27;. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br></pre></td></tr></table></figure>

<p>Then, the most important step, we copy current PCB’s Trapframe to it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Copy the current Trapframe below &#x27;KSTACKTOP&#x27; to the new env&#x27;s &#x27;env_tf&#x27;. */</span></span><br><span class="line">e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe*)KSTACKTOP - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Important!</strong> By copying current Trapframe, we copy the break point of current process to its child, which <strong>makes it resume at the same point</strong> with its parent! Notice that, Trapframe is set at once when process makes the system call, and the system call dispatcher will increase CP0.epc by 4 bytes before entering the handler, which make it jump over <code>syscall</code>. Then, we enter the real hander and do the fork. So, anything we do in system call <strong>does not affect the break point</strong> (mainly focus on PC), and child process will <strong>not</strong> execute system call again!</p>
</blockquote>
<p>Here, why we don’t just copy <code>curenv-&gt;env_tf</code> to it?  This is a little complicated, you can expand it optionally.</p>
<details class="toggle"><summary class="toggle-button" style>which one to copy</summary><div class="toggle-content"><p>Go carefully about the source code, and you’ll find that, for system calls that don’t make schedule, we only use <code>KSTACKTOP - TF_SIZE</code> to <code>KSTACK_TOP</code> to save and restore process break point. <code>Env::env_tf</code> is only used when schedule happens, to store process status and use it to restore that memory block next time it runs. So <code>Env::env_tf</code> is usually out of date.</p>
<p>As a further explanation, system call use <code>ret_from_exception</code> to restore registers with <code>KSTACK_TOP - TF_SIZE</code> to <code>KSTACK_TOP</code>, which also resets PC so it will go directly to the user process. This is what most system calls do at last. However, for system calls that involves schedule, be fore <code>ret_from_exception</code>, it will use <code>env_pop_tf</code> to restore <code>KSTACK_TOP - TF_SIZE</code> with <code>Env::env_tf</code> first, and then call <code>ret_from_exception</code> to jump to the new process.</p>
</div></details>

<p>To distinguish between parent and child, we set child process’s return value to 0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 3: Set the new env&#x27;s &#x27;env_tf.regs[2]&#x27; to 0 to indicate the return value in child. */</span></span><br><span class="line">e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Notice that, parent process hasn’t got its return value yet.</p>
</blockquote>
<p>At last, since child process is not ready to run (no memory allocated), we temporarily set its status to <code>ENV_NOT_RUNNABLE</code>, and priority the same as its parent.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 4: Set up the new env&#x27;s &#x27;env_status&#x27; and &#x27;env_pri&#x27;.  */</span></span><br><span class="line">e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">e-&gt;env_pri = curenv-&gt;env_pri;</span><br></pre></td></tr></table></figure>

<p>As all these things are executed in parent process, though in kernel, the return value will also be returned to parent process directly. So here we just return child process’ <code>Env::env_id</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> e-&gt;env_id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>So what’s the difference between the return value of parent and child? Well, parent process is a complete process then, yet child process only has a PCB. So child could not receive return value from function, so we have to ‘make’ its return value from nowhere.</p>
</blockquote>
<p>A complete view of this function.</p>
<details class="toggle"><summary class="toggle-button" style>sys_exofork</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">    try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line"></span><br><span class="line">    e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe*)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>It doesn’t do much. Yeah, I though it does everything. But it does not, other stuffs are done in user space.</p>
<h2 id="Fork-in-User-Space"><a href="#Fork-in-User-Space" class="headerlink" title="Fork in User Space"></a>Fork in User Space</h2><p>You can find user space fork in <code>user/include/lib.h</code> and <code>user/lib/fork.c</code>. But hold your horse, please. There are some basic concepts to understand before we meet fork.</p>
<h3 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h3><p>To reduce physical memory use, when we fork a child, we first make child share parent’s physical pages. If both parent and child do not write them, then we can save much memory. However, if one of them write one of the pages, it will invoke a TLB mod exception, which will then duplicate the page.</p>
<p>To mark such pages, we use <code>PTE_COW</code>. <code>PTE_COW</code> and <code>PTE_D</code> (write) is mutual exclusive. That is to say, such page can’t be written before copy.</p>
<p>However, though it is a kernel exception, the actual work is done by a user space function, which is stored in <code>Env::env_user_tlb_mod_entry</code>, and this entry is set to a user space handler <code>cow_entry</code>. <strong>This is a little tricky</strong>, and I’ll elaborate on it later, real soon.</p>
<p>What this entry does is just make a copy of the page, and jump back to the instruction that cause this exception.</p>
<details class="toggle"><summary class="toggle-button" style>cow_entry</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Map the faulting page to a private writable copy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> * 	&#x27;va&#x27; is the address which led to the TLB Mod exception.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *  - Launch a &#x27;user_panic&#x27; if &#x27;va&#x27; is not a copy-on-write page.</span></span><br><span class="line"><span class="comment"> *  - Otherwise, this handler should map a private writable copy of</span></span><br><span class="line"><span class="comment"> *    the faulting page at the same address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) cow_entry(<span class="keyword">struct</span> Trapframe* tf)</span><br><span class="line">&#123;</span><br><span class="line">	u_int va = tf-&gt;cp0_badvaddr;</span><br><span class="line">	u_int perm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Find the &#x27;perm&#x27; in which the faulting address &#x27;va&#x27; is mapped. */</span></span><br><span class="line">	<span class="comment">/* Hint: Use &#x27;vpt&#x27; and &#x27;VPN&#x27; to find the page table entry. If the &#x27;perm&#x27;</span></span><br><span class="line"><span class="comment">	 * doesn&#x27;t have &#x27;PTE_COW&#x27;, launch a &#x27;user_panic&#x27;. */</span></span><br><span class="line">	perm = PTE_PERM(vpt[VPN(va)]);</span><br><span class="line">	panic_on(!(perm &amp; PTE_COW));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Remove &#x27;PTE_COW&#x27; from the &#x27;perm&#x27;, and add &#x27;PTE_D&#x27; to it. */</span></span><br><span class="line">	perm = PTE_CLR(perm, PTE_COW);</span><br><span class="line">	perm = PTE_SET(perm, PTE_D);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 3: Allocate a new page at &#x27;UCOW&#x27;. */</span></span><br><span class="line">	syscall_mem_alloc(<span class="number">0</span>, (<span class="type">void</span>*)UCOW, perm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 4: Copy the content of the faulting page at &#x27;va&#x27; to &#x27;UCOW&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Hint: &#x27;va&#x27; may not be aligned to a page! */</span></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">void</span>*)UCOW, (<span class="type">void</span>*)ROUNDDOWN(va, BY2PG), BY2PG);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: Map the page at &#x27;UCOW&#x27; to &#x27;va&#x27; with the new &#x27;perm&#x27;.</span></span><br><span class="line">	syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span>*)UCOW, <span class="number">0</span>, (<span class="type">void</span>*)ROUNDDOWN(va, BY2PG), perm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 6: Unmap the page at &#x27;UCOW&#x27;.</span></span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span>*)UCOW);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 7: Return to the faulting routine.</span></span><br><span class="line">	<span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">	user_panic(<span class="string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>If you are confused about the jump between these functions, you can expand the following block.</p>
<details class="toggle"><summary class="toggle-button" style>tlb_mod_exception</summary><div class="toggle-content"><p>First, we have to review <code>do_tlb_mod</code>. When a TLB mod exception happens, we’ll first jump here.</p>
<details class="toggle"><summary class="toggle-button" style>do_tlb_mod</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_tlb_mod</span><span class="params">(<span class="keyword">struct</span> Trapframe* tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set $sp to user exception stack top. Since the whole trapframe will</span></span><br><span class="line"><span class="comment">     * be restored to what it was on exception, we can change it here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP)</span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Save current Trapframe to user exception stack. Since we have altered</span></span><br><span class="line"><span class="comment">     * base address of the stack, the user process won&#x27;t feel the difference.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">    *(<span class="keyword">struct</span> Trapframe*)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User must have such handler.</span></span><br><span class="line">    <span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Set parameter ($a0) of the following function call, this is the</span></span><br><span class="line"><span class="comment">         * parameter in env_user_tlb_mod_entry function, which is set to</span></span><br><span class="line"><span class="comment">         * cow_entry!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];           <span class="comment">// $a0 = &amp;temp_tf !</span></span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);  <span class="comment">// push $a0 to stack as param.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Make uesr process execute its TLB mod handler next, instead of</span></span><br><span class="line"><span class="comment">         * the normal order.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * So, you can see that, this kernel exception handler does nothing,</span></span><br><span class="line"><span class="comment">     * but changes user process&#x27; execution order only.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<p>After this, user process will continue to execute <code>cow_entry</code> after getting out of kernel. Notice that, user process still uses exception stack in <code>cow_entry</code> in order not to crash previous stack.</p>
<p>You may wonder, how do we get back to the right track? The answer is the parameter we passed to <code>env_user_tlb_mod_entry</code>. We stored the previous trapframe in exception stack to preserve it, and then from <code>cow_entry</code>, we can see that it uses this trapframe to jump back to where the exception happens! Brilliant!</p>
<blockquote>
<p>This is just like <code>setjmp()</code> and <code>longjmp</code> in C. :)</p>
</blockquote></div></details>

<h3 id="Duplicate-Pages"><a href="#Duplicate-Pages" class="headerlink" title="Duplicate Pages"></a>Duplicate Pages</h3><p>To achieve COW, we first need to make child process share those pages, and this is done by duplicating the link to them. And this is done by <code>duppage</code>. This function is relatively simple.</p>
<details class="toggle"><summary class="toggle-button" style>duppage</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">duppage</span><span class="params">(u_int envid, u_int vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_int addr;</span><br><span class="line">    u_int perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Get the permission of the page. */</span></span><br><span class="line">    <span class="comment">/* Hint: Use &#x27;vpt&#x27; to find the page table entry. */</span></span><br><span class="line">    addr = vpn &lt;&lt; PGSHIFT;</span><br><span class="line">    perm = PTE_PERM(vpt[vpn]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step 2: If the page is writable, and not shared with children, and not</span></span><br><span class="line"><span class="comment">     * marked as COW yet, then map it as copy-on-write, both in the parent (0)</span></span><br><span class="line"><span class="comment">     * and the child (envid).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> remap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_D) &amp;&amp; !(perm &amp; PTE_LIBRARY))</span><br><span class="line">    &#123;</span><br><span class="line">        perm = PTE_CLR(perm, PTE_D);</span><br><span class="line">        perm = PTE_SET(perm, PTE_COW);</span><br><span class="line">        remap = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syscall_mem_map(<span class="number">0</span>, addr, envid, addr, perm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remap)</span><br><span class="line">        syscall_mem_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<blockquote>
<p>Don’t be afraid of accessing virtual memory, they will be intercepted by MMU at last and translated to physical memory.</p>
</blockquote>
<p>One problem, why map child before remap to parent?</p>
<blockquote>
<p>Because, once we remap to parent, the pages will become read only, but we still need to write pages because of function calling stack!</p>
</blockquote>
<h3 id="Fork-1"><a href="#Fork-1" class="headerlink" title="Fork"></a>Fork</h3><p>Finally, we could have a glance at fork in user space. Now, it should be easy to understand. Just about to exit fork, we should set child process’ TLB mod entry. And as we have prepared everything for it, we can set it status to RUNNABLE.</p>
<p>Notice that, for child process, we have to set its <code>env</code> manually, since <code>env</code> is set at the start of a process to the Env it corresponds to, but child process doesn’t start normally, which makes that the same as its parent.</p>
<details class="toggle"><summary class="toggle-button" style>fork</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">    </span><br><span class="line">    u_int child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Set our TLB Mod user exception entry to &#x27;cow_entry&#x27; if not done yet. */</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry)</span><br><span class="line">        try(syscall_set_tlb_mod_entry(<span class="number">0</span>, cow_entry));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Step 2: Create a child env that&#x27;s not ready to be scheduled. */</span></span><br><span class="line">    <span class="comment">// Hint: &#x27;env&#x27; should always point to the current env itself, so we should fix</span></span><br><span class="line">    <span class="comment">// it to the correct value.</span></span><br><span class="line">    child = syscall_exofork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        env = envs + ENVX(syscall_getenvid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Map all mapped pages below &#x27;USTACKTOP&#x27; into the child&#x27;s address space. */</span></span><br><span class="line">    <span class="comment">// Hint: You should use &#x27;duppage&#x27;.</span></span><br><span class="line">    <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; USTACKTOP; i += BY2PG)</span><br><span class="line">    &#123;</span><br><span class="line">        u_int _vpn = VPN(i);</span><br><span class="line">        u_int _vpd = VPD(i);</span><br><span class="line">        <span class="keyword">if</span> ((vpd[_vpd] &amp; PTE_V) &amp;&amp; (vpt[_vpn] &amp; PTE_V))</span><br><span class="line">            duppage(child, _vpn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Set up the child&#x27;s tlb mod handler and set child&#x27;s &#x27;env_status&#x27; to</span></span><br><span class="line"><span class="comment">     * &#x27;ENV_RUNNABLE&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment">     *   You may use &#x27;syscall_set_tlb_mod_entry&#x27; and &#x27;syscall_set_env_status&#x27;</span></span><br><span class="line"><span class="comment">     *   Child&#x27;s TLB Mod user exception entry should handle COW, so set it to &#x27;cow_entry&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    try(syscall_set_tlb_mod_entry(child, cow_entry));</span><br><span class="line">    try(syscall_set_env_status(child, ENV_RUNNABLE));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>

<hr>
<h1 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h1><p>Well, I guess, this is it… Too many words. :(</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://tonys-studio.top">Tony Lewis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://blog.tonys-studio.top/posts/Lab-4-Reflection/">https://blog.tonys-studio.top/posts/Lab-4-Reflection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/BUAA/">BUAA</a></div><div class="post-share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_wechat"></a><a class="a2a_button_qzone"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Configure-VS-for-Non-MSVC-Projects/" title="Configure Visual Studio for Non-MSVC Projects"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/11/09.jpeg" onerror="onerror=null;src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Configure Visual Studio for Non-MSVC Projects</div></div><div class="info-2"><div class="info-item-1">Configure VS IntelliSense for GCC</div></div></div></a><a class="pagination-related" href="/posts/Lab-2-Extra-Reflection/" title="Lab 2 Extra Reflection"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/02/06.jpeg" onerror="onerror=null;src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Lab 2 Extra Reflection</div></div><div class="info-2"><div class="info-item-1">Reflection on 2023 BUAA OS Lab 2 Extra</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/File-System-IPC/" title="File System IPC"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/06/05.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> May. 6th, 2023 - 11:47:57</div><div class="info-item-2">File System IPC</div></div><div class="info-2"><div class="info-item-1">Brief on File System IPC Mechanism</div></div></div></a><a class="pagination-related" href="/posts/Lab-2-Extra-Reflection/" title="Lab 2 Extra Reflection"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/02/06.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Apr. 6th, 2023 - 19:53:06</div><div class="info-item-2">Lab 2 Extra Reflection</div></div><div class="info-2"><div class="info-item-1">Reflection on 2023 BUAA OS Lab 2 Extra</div></div></div></a><a class="pagination-related" href="/posts/Lab-5-Reflection/" title="Lab 5 Reflection"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/01/03.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> May. 6th, 2023 - 11:47:42</div><div class="info-item-2">Lab 5 Reflection</div></div><div class="info-2"><div class="info-item-1">Reflection on 2023 BUAA OS Lab 5 - File System</div></div></div></a><a class="pagination-related" href="/posts/Lab-6-Challenge/" title="Lab 6 Challenge"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/02/09.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jun. 18th, 2023 - 23:28:24</div><div class="info-item-2">Lab 6 Challenge</div></div><div class="info-2"><div class="info-item-1">Lab 6 Challenge - A More Powerful Shell</div></div></div></a><a class="pagination-related" href="/posts/Lab-6-Reflection/" title="Lab 6 Reflection"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/01/02.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jun. 18th, 2023 - 23:28:19</div><div class="info-item-2">Lab 6 Reflection</div></div><div class="info-2"><div class="info-item-1">Reflection on 2023 BUAA OS Lab 6 - Pipe & Shell</div></div></div></a><a class="pagination-related" href="/posts/Page-Directory-Self-Mapping/" title="Page Directory Self Mapping"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/22/13.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Mar. 25th, 2023 - 20:56:35</div><div class="info-item-2">Page Directory Self Mapping</div></div><div class="info-2"><div class="info-item-1">Understanding page directory self mapping</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/avatar.png" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/missing.gif'" alt="avatar"/></div><div class="author-info-name">Tony Lewis</div><div class="author-info-description">Do or do not. There is no try.</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">94</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">41</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Lord-Turmoil" target="_blank" title="Github"><i class="fa-brands fa-github"></i></a><a class="social-icon" href="mailto:swift-phantom@outlook.com" target="_blank" title="Email"><i class="fa-solid fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/2030942344" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">It won't be long before the armies of the Republic track us here.<br>You can visit this site at both:<li><a href="http://blog.tonys-studio.top/" target="_blank">Main Site</a></li><li><a href="https://lord-turmoil.github.io/" target="_blank">Github Mirror Site</a></li></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BUAA-2023-Spring-OS"><span class="toc-text">BUAA 2023 Spring OS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Prologue"><span class="toc-text">Prologue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#A-%E2%80%9CCall%E2%80%9D-to-Answer"><span class="toc-text">A “Call” to Answer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#User-Call"><span class="toc-text">User Call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kernel-Answer"><span class="toc-text">Kernel Answer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception-Handler"><span class="toc-text">Exception Handler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Basic-System-Calls"><span class="toc-text">Basic System Calls</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Identify-Process"><span class="toc-text">Identify Process</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Management"><span class="toc-text">Memory Management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sys-mem-alloc"><span class="toc-text">sys_mem_alloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sys-mem-map"><span class="toc-text">sys_mem_map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sys-mem-unmap"><span class="toc-text">sys_mem_unmap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Schedule"><span class="toc-text">Schedule</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Inter-Process-Communication"><span class="toc-text">Inter-Process Communication</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sys-ipc-recv"><span class="toc-text">sys_ipc_recv</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sys-ipc-try-send"><span class="toc-text">sys_ipc_try_send</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fork"><span class="toc-text">Fork</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-in-Kernel-Space"><span class="toc-text">Fork in Kernel Space</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-in-User-Space"><span class="toc-text">Fork in User Space</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-on-Write"><span class="toc-text">Copy on Write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Duplicate-Pages"><span class="toc-text">Duplicate Pages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-1"><span class="toc-text">Fork</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Epilogue"><span class="toc-text">Epilogue</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Lambda-Calculus-A-Preliminary-View/" title="Lambda Calculus: A Preliminary View"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/01/05.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Lambda Calculus: A Preliminary View"/></a><div class="content"><a class="title" href="/posts/Lambda-Calculus-A-Preliminary-View/" title="Lambda Calculus: A Preliminary View">Lambda Calculus: A Preliminary View</a><time datetime="2025-09-16T08:25:34.000Z" title="Created Sep. 16th, 2025 - 16:25:34 16:25:34">Sep. 16th, 2025 - 16:25:34</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Music-Notation-with-Avid-Sibelius/" title="Music Notation With Avid Sibelius"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/posts/Music-Notation-with-Avid-Sibelius.jpg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Music Notation With Avid Sibelius"/></a><div class="content"><a class="title" href="/posts/Music-Notation-with-Avid-Sibelius/" title="Music Notation With Avid Sibelius">Music Notation With Avid Sibelius</a><time datetime="2025-09-03T04:34:54.000Z" title="Created Sep. 3rd, 2025 - 12:34:54 12:34:54">Sep. 3rd, 2025 - 12:34:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/10/04.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Getting Started With Coq"/></a><div class="content"><a class="title" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq">Getting Started With Coq</a><time datetime="2025-08-08T04:30:12.000Z" title="Created Aug. 8th, 2025 - 12:30:12 12:30:12">Aug. 8th, 2025 - 12:30:12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/" title="Game Engine 0 to 1 (02): Something on the Screen"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/15/03.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Game Engine 0 to 1 (02): Something on the Screen"/></a><div class="content"><a class="title" href="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/" title="Game Engine 0 to 1 (02): Something on the Screen">Game Engine 0 to 1 (02): Something on the Screen</a><time datetime="2025-07-04T12:07:57.000Z" title="Created Jul. 4th, 2025 - 20:07:57 20:07:57">Jul. 4th, 2025 - 20:07:57</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/21/10.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Game Engine 0 to 1 (01): It Starts Now"/></a><div class="content"><a class="title" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now">Game Engine 0 to 1 (01): It Starts Now</a><time datetime="2025-06-01T06:45:32.000Z" title="Created Jun. 1st, 2025 - 14:45:32 14:45:32">Jun. 1st, 2025 - 14:45:32</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/02/03.jpeg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Tony Lewis</span></div><div class="footer_custom_text">No bird soars too high if he soars on his own wings</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'forest'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://comment.tonys-studio.top',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client@2/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client@2/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/static/custom.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="local-search-input"><input placeholder="Anything you would like to search?🔍" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="Framework Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo%205.4.2-blue?style=flat-square&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="Theme Butterfly" title=""><img src="https://img.shields.io/badge/Theme-Butterfly%205.4.3-6513df?style=flat-square&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="All articles in this blog are licensed under CC BY-NC-SA 4.0 unless stating additionally." title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat-square&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><!-- hexo injector body_end end --></body></html>