<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Game Engine 0 to 1 (02): Something on the Screen | TONY'S STUDIO</title><meta name="author" content="Tony Lewis"><meta name="copyright" content="Tony Lewis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#300303"><meta name="description" content="Game Engine Series 02: Graphics Device">
<meta property="og:type" content="article">
<meta property="og:title" content="Game Engine 0 to 1 (02): Something on the Screen">
<meta property="og:url" content="https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/">
<meta property="og:site_name" content="TONY&#39;S STUDIO">
<meta property="og:description" content="Game Engine Series 02: Graphics Device">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/12/05.jpeg">
<meta property="article:published_time" content="2025-07-04T12:07:57.000Z">
<meta property="article:modified_time" content="2025-09-03T04:35:40.714Z">
<meta property="article:author" content="Tony Lewis">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Game Engine 0 to 1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/12/05.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Game Engine 0 to 1 (02): Something on the Screen",
  "url": "https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/",
  "image": "https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/12/05.jpeg",
  "datePublished": "2025-07-04T12:07:57.000Z",
  "dateModified": "2025-09-03T04:35:40.714Z",
  "author": [
    {
      "@type": "Person",
      "name": "Tony Lewis",
      "url": "https://tonys-studio.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/favicon.svg"><link rel="canonical" href="https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-R6O16YoeQt"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#300303')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?68629f5da0a0c3347b896920fbf164b5";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "sthrplbt7c");
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":10,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":256,"languages":{"author":"Author: Tony Lewis","link":"Link: ","source":"Source: TONY'S STUDIO","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#871798","bgDark":"#C81025","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Game Engine 0 to 1 (02): Something on the Screen',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-footer-beautify@1.0.6/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/css/barber-shop.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/avatar.png" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/missing.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">93</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">84</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">40</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-jedi fa-beat"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/12/05.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/logo.svg" alt="Logo"><span class="site-name">TONY'S STUDIO</span></a><a class="nav-page-title" href="/"><span class="site-name">Game Engine 0 to 1 (02): Something on the Screen</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-jedi fa-beat"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Game Engine 0 to 1 (02): Something on the Screen</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-04T12:07:57.000Z" title="Created Jul. 4th, 2025 - 20:07:57 20:07:57">Jul. 4th, 2025 - 20:07:57</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-09-03T04:35:40.714Z" title="Updated Sep. 3rd, 2025 - 12:35:40 12:35:40">Sep. 3rd, 2025 - 12:35:40</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Game-Hobby/">Game &amp; Hobby</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Game-Hobby/Game-Development/">Game Development</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>29mins</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span class="waline-pageview-count" data-path="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/#post-comment"><span class="waline-comment-count" data-path="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p style="text-align: center; font-size: x-large"><b>[02] Something on the Screen</b></p>

<p style="text-align: center">
    <i>&ldquo;Got this love, I can feel,</i><br>
    <i>And I know, yes for sure, it is real.</i><br>
    <i>And it feels as though I've seen your face a thousand times...&rdquo;</i>
</p>
<p style="text-align: right"><i>&mdash; Michael Jackson (This is it)</i></p>

<div class="note primary flat"><p>你可以在 <a href="/tags/Game-Engine-0-to-1/">Game Engine 0 to 1</a> 标签下浏览该系列的所有文章。</p>
</div>

<div class="note success flat"><p>DungineX 完全开源，代码托管在 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX">GitHub</a>，本章对应<a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/tree/0.1.1">🏷️0.1.1</a>。</p>
</div>

<p>在本章中，主要介绍 DungineX 中图形设备的设计与实现，从如何创建窗口到实现各种绘制功能。不过，作为一个从零开始的项目，还有很多基础组件有待实现，例如日志、工具方法等，因此也会对这些主题进行穿插介绍。</p>
<div class="note warning flat"><p>由于一些别扭的翻译原因，Texture 可以翻译为纹理，也指图片。所以在本文中提到纹理和图片均指 Texture。</p>
</div>

<hr>
<h1 id="设备抽象"><a href="#设备抽象" class="headerlink" title="设备抽象"></a>设备抽象</h1><p>首先，我想有必要回顾一下设备（Device）的概念。</p>
<p>什么是设备？我们都知道，根据冯·诺依曼架构，计算机分为控制器、运算器、存储、输入和输出五个部分，而设备主要就指的是其中的输入和输出。对于游戏，通常的输出设备就是屏幕和扬声器，而输入设备就是鼠标和键盘。游戏需要能够显示画面，播放声音，接收玩家的操作，因此设备接口对于游戏编写十分重要。</p>
<h2 id="为什么需要设备抽象？"><a href="#为什么需要设备抽象？" class="headerlink" title="为什么需要设备抽象？"></a>为什么需要设备抽象？</h2><p>这个问题的答案非常显然，当然是为了方便使用。设备通常与硬件相关，而不同的硬件设备有不同的接口，由用户直接调用这些接口十分不便。这里有一张图非常生动形象，虽然是用来描述操作系统的，但是在这里同样合适。设备抽象要做的，就是屏蔽底层硬件细节，为用户提供统一、易用的接口。</p>
<img src="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/image-20250625231138135.png" alt="image-20250625231138135" style="zoom: 50%;">

<p>虽然现有的一些库，比如 <a target="_blank" rel="noopener" href="https://www.libsdl.org/">SDL3</a>、<a target="_blank" rel="noopener" href="https://www.fmod.com/">FMOD</a> 等已经提供了必要的抽象，从而可以相对简单的实现对应功能， 但是这些接口毕竟不是我们自己实现的，如果不进行抽象，则很难与我们的项目整合在一起。此外，这些接口的设计往往考虑到通用性，因此在游戏开发场景下可能还需进一步的封装。</p>
<p>具体地，设备抽象能够在以下两点为我们提供便利：</p>
<ul>
<li><strong>屏蔽底层细节</strong>。底层的组件往往考虑到通用性，相对晦涩复杂，因此在设备抽象中，可以根据具体的使用场景提供简化的 API。</li>
<li><strong>提高灵活性。</strong>部分情况下，同一个服务可以有不同的实现，比如对于音频设备，我们可以使用 SDL3，也可以使用 FMOD，甚至可以禁用音频设备。有了设备抽象的存在，用户将使用统一的接口访问底层的设备支持，而不用关注具体的实现。这是否让你想到了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a>？</li>
<li><strong>方便模块间通信。</strong>这个就很容易理解了，根据我们自定义的抽象，可以更方便地实现各个组件的相互调用。</li>
</ul>
<h2 id="图形设备抽象"><a href="#图形设备抽象" class="headerlink" title="图形设备抽象"></a>图形设备抽象</h2><p>当然，这次的主题还是图形设备。对于图形设备，其主要负责窗口的管理，以及图形绘制。</p>
<div class="note info flat"><p>为什么窗口会和绘制耦合在一起，原因在于，由于绘制缓冲区的存在，绘制指令往往依赖于图形上下文，而这一上下文通常绑定在一个窗口实例上。例如，在 SDL 中，渲染器（Renderer）依赖于当前窗口。</p>
</div>

<p>对于图形绘制，可以进一步分为三类对象的绘制，或者说渲染（Render）。</p>
<ul>
<li>原生（Primitive）图形，也就是像素点、线，矩形等。</li>
<li>纹理（Texture），其实也就是绘制图片，因此这里也会涉及图片的加载。</li>
<li>文本（Text），这个比较特别，相对更加 tricky，之后会具体介绍。</li>
</ul>
<p>提供这些接口的抽象后，用户就可以实现最基础绘制，在屏幕上显示有趣的图像了。</p>
<hr>
<h1 id="Infrastructure"><a href="#Infrastructure" class="headerlink" title="Infrastructure"></a>Infrastructure</h1><p>不过，在我们开始实现图形设备接口之前，还需要一些准备工作。对于一个较大规模的项目来说，通常需要一些“基础设施”的支持，比如 C&#x2F;C++ 很喜欢的类型别名，日志输出等。</p>
<h2 id="类型别名（Type-Alias）"><a href="#类型别名（Type-Alias）" class="headerlink" title="类型别名（Type Alias）"></a>类型别名（Type Alias）</h2><p>可能是 C&#x2F;C++ 支持这一特性的缘故吧，几乎所有项目都会有这一操作，一方面是为了可移植性，另一方面也是一种偷懒的方式吧。这也是我喜欢 C，尤其是 C++ 的原因之一，因为其提供了其他语言无法媲美的灵活性。</p>
<p>内存漏洞是 C++ 常常被诟病的问题，然而，现代的 C++ 已经有很完善的机制避免相关问题了，也就是智能指针 <code>std::shared_ptr</code>。通过将代码中的裸指针替换为智能指针，便能很大程度上避免，甚至消除内存相关问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Ref = std::shared_ptr&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">constexpr</span> Ref&lt;T&gt; <span class="title">CreateRef</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info flat"><p>这一类型定义方法来自 <a target="_blank" rel="noopener" href="https://github.com/TheCherno">The Cherno</a> 的 <a target="_blank" rel="noopener" href="https://github.com/TheCherno/Hazel">Hazel</a>。</p>
</div>

<p>除了智能指针封装外，目前还没有遇到其他特别的类型，具体可以参考 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Utils/Types.h">Utils\Types.h</a>。当然，我们可以为基本类型定义别名，比如 <code>uint32</code> 等，但其实头文件 <code>cstdint</code> 已经提供了相关定义了。</p>
<h2 id="日志输出（Logging）"><a href="#日志输出（Logging）" class="headerlink" title="日志输出（Logging）"></a>日志输出（Logging）</h2><p>尽管是自己亲手编写的程序，你是否时常会苦恼于难以定位错误，或是追踪程序的执行状态？对于这一问题，为程序添加日志输出是一个非常好的解决方案。在 DungineX 中，我们选择 <a target="_blank" rel="noopener" href="https://github.com/gabime/spdlog">spdlog</a> 作为日志库，一方面是因为其灵活性与高性能，另一方面是因为我对它相对更加熟悉。</p>
<p>本节中，我简单介绍 DungineX 中的日志系统，具体的日志系统声明可参考 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Utils/Log.h">Utils&#x2F;Log.h</a> 和 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Utils/Log.cpp">Utils&#x2F;Log.cpp</a>。</p>
<h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>日志输出通常有以下几个配置选项：</p>
<ul>
<li>名称（Name），最好可以通过名称区分不同组件的日志。</li>
<li>等级（Level），用来区分不同重要程度的日志消息。</li>
<li>目标（Sink），日志输出到哪里，控制台还是文件，还是多个目标。</li>
<li>格式（Format），具体的日志消息是什么样子的。</li>
</ul>
<p>因此，我们的日志配置如下，即 <code>LoggerSpecification</code>。注意到这里使用 <code>std::initializer_list</code> 来避免显式传入 <code>std::vector</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LoggerSinkSpecification</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string Path;</span><br><span class="line">    std::string Pattern;</span><br><span class="line">    </span><br><span class="line">    <span class="function">DGEX_API <span class="title">LoggerSinkSpecification</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API <span class="title">LoggerSinkSpecification</span><span class="params">(std::string path, std::string pattern)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoggerSpecification</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string Name;</span><br><span class="line">    LogLevel Level;</span><br><span class="line">    std::vector&lt;LoggerSinkSpecification&gt; Sinks;</span><br><span class="line">    </span><br><span class="line">    <span class="function">DGEX_API <span class="title">LoggerSpecification</span><span class="params">(std::string name, LogLevel level, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 std::initializer_list&lt;LoggerSinkSpecification&gt; sinks)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div class="note success flat"><p>或许你看到这里大写的成员名称有些惊讶，这一风格来自我编写 C# 代码的经验，来标识 public 成员。</p>
</div>

<h3 id="哪里需要-DGEX-API？"><a href="#哪里需要-DGEX-API？" class="headerlink" title="哪里需要 DGEX_API？"></a>哪里需要 <code>DGEX_API</code>？</h3><p>虽然有些突兀，但是我们在这里第一次遇到这一问题。在 <code>LoggerSpecification</code> 中，我们只给构造函数添加了 <code>DGEX_API</code>，即 <code>__declspec(dllexport)</code>，那为什么不给成员变量也添加呢，或是更激进一些，直接为整个结构体添加这一属性呢？</p>
<div class="note info flat"><p>你可以自行尝试给整个结构体添加 <code>DGEX_API</code>，看看会发生什么。</p>
</div>

<p>这里的原因在于，<code>__declspec(dllexport)</code> 类似于 DLL 编写者与使用者之前的一个“约定”，即被标记的声明应当保持兼容，也就是说，即使更新了 DLL，客户端仍然能够以相同的方式调用被标记的“东西”。</p>
<p>那么问题就来了，对于函数，本质就是一个固定大小的地址，那么我们只要保证提供这个地址就可以。而对于成员变量，就不只是地址了，还有大小。成员大小取决于类型， 因此为了遵守“约定”，对应的类型也需要被标记，于是你会遇到 <code>__declspec(dllexport)</code> 传播的问题。对于自定义的类型，比如 <code>LogLevel</code>，可以直接标记，而对于像 <code>std::string</code> 这样的标准库类型，由于其并不提供 DLL 导出，所以我们也没办法实现导出。不过，由于成员最终会变成地址偏移量，而头文件是提供给客户端的，因此用户可以获得相应的类型的声明，只要偏移量和大小一致，便能正确实现运行时的访问。</p>
<p>因此，我们只需要标记需要导出的函数即可。当然，不一定所有函数都需要导出，因此可以有选择地隐藏部分接口。不过，如果用户选择静态链接，那么其实还是可以使用所有接口，最根本的隐藏接口的方法还是将其放在私有头文件目录下，但是会相对麻烦些。</p>
<div class="note warning flat"><p>目前，我们认为只有 DLL 暴露的接口为公开接口。</p>
</div>

<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>接下来，是日志系统。恰当的日志能够让我们高效地排查程序中的问题，并且观测程序的执行状态。DungineX 中的 Logger 声明如下。我们刚刚说过，通常不应该，也不能导出整个结构体或类，而是导出其中对外暴露的方法，所以这里只导出对应的日志输出方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> LoggerSpecification&amp; specification);</span><br><span class="line">    ~<span class="built_in">Logger</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt; <span class="function">DGEX_API <span class="type">void</span> <span class="title">Debug</span><span class="params">(spdlog::<span class="type">format_string_t</span>&lt;Args...&gt; fmt, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _impl-&gt;<span class="built_in">debug</span>(fmt, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">    Ref&lt;spdlog::logger&gt; _impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div class="note success flat"><p>从 Logger 中，已经可以看到些许 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> 的影子了，即在构造函数中完成资源的初始化。</p>
</div>

<p>我们不希望用户随便创建 Logger，所以没有用 <code>DGEX_API</code> 标记构造和析构函数，而是将 Logger 的注册和获取放在了静态类 <code>Log</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DGEX_API <span class="type">static</span> Ref&lt;Logger&gt; <span class="title">GetLogger</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API <span class="type">static</span> Ref&lt;Logger&gt; <span class="title">RegisterLogger</span><span class="params">(<span class="type">const</span> LoggerSpecification&amp; specification)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> std::unordered_map&lt;std::string, Ref&lt;Logger&gt;&gt; _sLoggers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，我们可以用宏实现简化的日志输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _DGEX_LOGGER(NAME) DGEX Log::GetLogger(NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_LOG_DEBUG(NAME, ...) _DGEX_LOGGER(NAME)-&gt;Debug(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<h2 id="Assertion"><a href="#Assertion" class="headerlink" title="Assertion"></a>Assertion</h2><p>对于 C&#x2F;C++ 这样没有运行时检查的语言来说，有时需要我们手动进行一些边界或条件检查。标准库提供的 <code>assert</code> 功能过于简单，我们尤其希望能够将 assert 的结果输出到日志，因此我们的 assert 可以和日志系统相结合。具体的 assert 实现见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Utils/Assert.h">Utils&#x2F;Assert.h</a>。</p>
<hr>
<h1 id="Pit-Fall"><a href="#Pit-Fall" class="headerlink" title="Pit Fall"></a>Pit Fall</h1><p>有了基础设施之后，我们就可以正式开始编码了。由于是第一次使用 SDL3，而且是一个比较特殊的场景（将 SDL3 打包进 DLL），遇到了一些问题，也花了很多功夫解决。在开始前，对相关问题进行说明。</p>
<h2 id="上下文绑定"><a href="#上下文绑定" class="headerlink" title="上下文绑定"></a>上下文绑定</h2><p>这一问题确实很奇怪，对于 DungineX，我们将 SDL3 打包进引擎，再以 DLL 的形式提供给用户，看似没什么问题，但是却会使 SDL 的上下文管理出问题。</p>
<p>这一问题具体表现为，如果客户端只通过 DungineX 的接口调用 SDL，那么一切正常。而一旦客户端直接调用了 SDL 中标记只能在主线程中调用的函数，那么程序就会挂起（Hang）。</p>
<p>按理说 DLL 和程序运行在同一线程，但是可能因为 DLL 的加载，SDL 的上下文初始化机制，以及大量使用锁进行同步，导致二者不能共享同一上下文吧，所以导致了死锁。</p>
<div class="note danger flat"><p>具体原因还有待进一步探究。</p>
</div>

<h2 id="Entry-Point"><a href="#Entry-Point" class="headerlink" title="Entry Point"></a>Entry Point</h2><p>刚刚提到了上下文绑定的问题，客户端不能直接调用 SDL 的函数，所以也就不能使用 SDL 提供的生命周期回调了。因此需要我们自行实现程序的入口。</p>
<p><a href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/">上一章</a>中的入口实现还很简单，本章中进行了更新，会在之后具体介绍。</p>
<hr>
<h1 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h1><p>下面，我们正式开始图形设备的编写。首先，自然是创建一个窗口，具体代码见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Window.h">Device&#x2F;Graphics&#x2F;Window.h</a> 和 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Device/Graphics/Window.cpp">Device\Graphics\Window.cpp</a>。</p>
<h2 id="窗口属性"><a href="#窗口属性" class="headerlink" title="窗口属性"></a>窗口属性</h2><p>对于一个窗口，其主要的属性很简单，无非是标题、大小以及一些选项，比如是否可缩放、是否全屏等。对此，我们可以定义如下的窗口属性。类似的，我们只将构造函数标记为 <code>DGEX_API</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> WindowFlags = <span class="type">unsigned</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> : <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">&#123;</span><br><span class="line">    DgexWindowDefault            = <span class="number">0</span>,</span><br><span class="line">    DgexWindowAlwaysOnTop        = <span class="built_in">DGEX_BIT</span>(<span class="number">0</span>),    <span class="comment">// always on top</span></span><br><span class="line">    DgexWindowBorderless         = <span class="built_in">DGEX_BIT</span>(<span class="number">1</span>),    <span class="comment">// launch as borderless window</span></span><br><span class="line">    DgexWindowFullScreen         = <span class="built_in">DGEX_BIT</span>(<span class="number">2</span>),    <span class="comment">// launch in fullscreen</span></span><br><span class="line">    DgexWindowResizable          = <span class="built_in">DGEX_BIT</span>(<span class="number">3</span>),    <span class="comment">// allow window to resize</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WindowProperties</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string Title;</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    WindowFlags Flags;</span><br><span class="line"></span><br><span class="line">    <span class="function">DGEX_API <span class="title">WindowProperties</span><span class="params">(std::string title, <span class="type">int</span> width, <span class="type">int</span> height, WindowFlags flags)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，窗口的创建由 DungineX 完成，那么为了使用户能够自定义窗口属性，可以提供这样一个函数，在创建窗口前，由用户提供自定义的窗口属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">SetWindowPropertiesHint</span><span class="params">(<span class="type">const</span> WindowProperties&amp; properties)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="窗口创建-1"><a href="#窗口创建-1" class="headerlink" title="窗口创建"></a>窗口创建</h2><p>一个程序可能不止一个窗口，不过对于游戏来说，一个窗口足矣。因此，我们可以通过这种方式访问具体的窗口实例，当然这个接口不对用户暴露。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SDL_Window* sNativeWindow = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SDL_Window* <span class="title">GetNativeWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DGEX_ASSERT</span>(sNativeWindow, <span class="string">&quot;Window not initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sNativeWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info flat"><p>为了实现对 SDL 接口彻底的封装，我们不应当向用户暴露任何 SDL 的函数和类型。</p>
</div>

<p>对于窗口的创建，SDL 已经封装得很好了，我们只需要将我们自定义的窗口选项转化为 SDL 支持的窗口选项，并调用 <code>SDL_CreateWindow</code> 即可。同时，这里也展示了日志的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">dgex_error_t</span> <span class="title">InitWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDL_Window* window = <span class="built_in">SDL_CreateWindow</span>(</span><br><span class="line">        sWindowPropertiesHint.Title.<span class="built_in">c_str</span>(),</span><br><span class="line">        sWindowPropertiesHint.Width,</span><br><span class="line">        sWindowPropertiesHint.Height,</span><br><span class="line">        <span class="built_in">GetSdlWindowFlags</span>(sWindowPropertiesHint.Flags));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DGEX_CORE_ERROR</span>(<span class="string">&quot;Failed to create window: &#123;0&#125;&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">        <span class="keyword">return</span> DGEX_ERROR_WINDOW_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sNativeWindow = window;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line">    <span class="built_in">SDL_GetWindowSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">&quot;Window size: &#123;0&#125;x&#123;1&#125;&quot;</span>, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SDL_ShowWindow</span>(sNativeWindow);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">&quot;Window initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DGEX_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info flat"><p>关于日志输出的格式，可以参考 <a target="_blank" rel="noopener" href="https://github.com/gabime/spdlog/wiki">spdlog 的官方文档</a>。</p>
</div>

<p>现在，我们在调用 <code>InitWindow</code> 函数后，就可以得到一个窗口了。</p>
<div class="note info flat"><p>目前，在得到图形窗口时，控制台窗口依然存在，这是因为我们最终链接构建的是控制台应用。想要去掉控制台，可以之后切换至 Windows 窗口应用，使用 <code>WinMain</code> 代替 <code>main</code>。</p>
</div>

<hr>
<h1 id="绘图接口"><a href="#绘图接口" class="headerlink" title="绘图接口"></a>绘图接口</h1><p>此时，我们已经能够得到一个黑黑的窗口，接下来，就可以在其中实现图形的绘制了。对于游戏来说，我们通常需要实现以下几个绘图功能：</p>
<ul>
<li>在屏幕上绘制点、线等图形，以及图片和文字。</li>
<li>支持图像的缩放、旋转等效果。</li>
<li>在指定目标实现绘制。</li>
</ul>
<p>总结起来，你需要了解以下几点概念。</p>
<ul>
<li>绘制目标：本质是一块缓冲区，可以是屏幕，也可以是图片（纹理）。</li>
<li>绘图属性：比如线条颜色、文字大小等。</li>
<li>图像绘制：在绘图设备上实现绘制，包括原生图形，图片以及文字。</li>
</ul>
<p>这些概念看起来很简单<del>，实际一点也不复杂</del>，SDL 已经提供了相应的封装，因此我们的任务很轻松。具体的绘制接口声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Renderer/RenderApi.h">Renderer&#x2F;RenderApi.h</a>。</p>
<h2 id="创建渲染器"><a href="#创建渲染器" class="headerlink" title="创建渲染器"></a>创建渲染器</h2><p>SDL 的所有绘制操作都由 <code>SDL_Renderer</code> 完成，其绑定在当前窗口上，从而实现该窗口的绘制和渲染任务。在我们创建好窗口后，就可以初始化渲染器了。具体的渲染器初始化如下，与窗口类似，使用 <code>sNativeRenderer</code> 维护渲染器实例，便于最终释放资源。为了更好地展示 SDL 的功能，在初始化渲染器时，列出了所有可用的 Renderer Driver，可以看到 SDL 支持 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/direct3d">Direct3D</a>，<a target="_blank" rel="noopener" href="https://www.opengl.org/">OpenGL</a>，<a target="_blank" rel="noopener" href="https://www.vulkan.org/">Vulkan</a> 等多个渲染后端。当然，这里我们最终让 SDL 自行选择。由于按照字典序选择， 因此很可能会选择 Direct3D。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">dgex_error_t</span> <span class="title">InitRenderer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">SDL_GetNumRenderDrivers</span>();</span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">&quot;Available render drivers: &#123;0&#125;&quot;</span>, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* name = <span class="built_in">SDL_GetRenderDriver</span>(i);</span><br><span class="line">        <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">&quot;    Render driver &#123;0&#125;: &#123;1&#125;&quot;</span>, i, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_Renderer* renderer = <span class="built_in">SDL_CreateRenderer</span>(<span class="built_in">GetNativeWindow</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!renderer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DGEX_CORE_ERROR</span>(<span class="string">&quot;Failed to initialize renderer: &#123;0&#125;&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">        <span class="keyword">return</span> DGEX_ERROR_RENDERER_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_PropertiesID props = <span class="built_in">SDL_GetRendererProperties</span>(renderer);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="built_in">SDL_GetStringProperty</span>(props, SDL_PROP_RENDERER_NAME_STRING, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">&quot;Using renderer: &#123;0&#125;&quot;</span>, name ? name : <span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SDL_SetRenderVSync</span>(renderer, <span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DGEX_CORE_WARN</span>(<span class="string">&quot;VSync not supported: &#123;0&#125;&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sNativeRenderer = renderer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">&quot;Renderer initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DGEX_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="note warning flat"><p>很奇怪，在我本地 SDL 始终无法支持 VSync，即使更换渲染后端还是无果，不过由于已经使用了双缓冲，是否使用 VSync 其实并不重要。</p>
</div>

<h3 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h3><p>DungineX 是一个 2D 游戏引擎，虽然是 2D，但是在处理伪 3D 场景时仍存在遮挡问题。在 OpenGL 中，我们可以指定顶点的三维坐标，由 OpenGL 决定渲染的遮挡关系。而 SDL 只支持 2D 绘制，不存在 Z 轴来支持深度检测，因此只能用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Painter's_algorithm">画家算法（Painter‘s Algorithm）</a>实现正确的图像遮挡关系。</p>
<p>虽然画家算法很简单，但是需要时刻关注对象的位置关系，会为用户带来很多麻烦。因此，我们可以对渲染器进行封装，从而支持一个虚拟的 Z 轴。</p>
<h3 id="绘制指令"><a href="#绘制指令" class="headerlink" title="绘制指令"></a>绘制指令</h3><p>既然 SDL 不支持 Z 轴，那么我们可以抽象出支持 Z 轴的绘制指令。通过 <code>RenderCommand</code> 将具体的绘制动作封装起来，就可以实现对 RenderCommand 的排序，进而支持绘制的排序，具体的声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Device/Graphics/RenderCommand.h">Device&#x2F;Graphics&#x2F;RenderCommand.h</a>。由于用户无需了解 RenderCommand，所以我们可以将其放在私有目录下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RenderCommand</span>(<span class="type">int</span> order);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetOrder</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Apply</span><span class="params">(SDL_Renderer* renderer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _order;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体地，我们可以进一步实现具体的绘制指令，具体的声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Renderer/RenderCommandImpl.h">Renderer&#x2F;RenderCommandImpl.h</a>。</p>
<p>首先，是原生绘制指令的封装，将绘制操作打包成匿名函数，从而可以在排序后进行调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NativeRenderCommand</span> <span class="keyword">final</span> : <span class="keyword">public</span> RenderCommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> RenderAction = std::function&lt;<span class="built_in">void</span>(SDL_Renderer*)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NativeRenderCommand</span>(<span class="type">const</span> RenderAction&amp; action, <span class="type">int</span> order);</span><br><span class="line">    ~<span class="built_in">NativeRenderCommand</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(SDL_Renderer* renderer)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Ref&lt;NativeRenderCommand&gt; <span class="title">Create</span><span class="params">(<span class="type">const</span> RenderAction&amp; action, <span class="type">int</span> order = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RenderAction _action;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实这一个封装就足够了，但是由于图像绘制参数实在是太多，不仅有 <code>Texture</code> 对象，还有位置、缩放、旋转、翻转、锚点等，所以也值得我们为它封装一个绘制指令。<code>TextureRenderCommand</code> 相对复杂，具体见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Renderer/RenderCommandImpl.h">Renderer&#x2F;RenderCommandImpl.h</a>。</p>
<h3 id="渲染器封装"><a href="#渲染器封装" class="headerlink" title="渲染器封装"></a>渲染器封装</h3><p>有了绘制指令后，我们要做的就是让渲染器识别我们的虚拟 Z 轴。渲染器的封装如下，支持提交绘制指令，以及执行绘制。同理，这里我们不希望用户直接创建 <code>Renderer</code>，或是提交绘制指令，因此只暴露 <code>Render()</code> 方法，详细声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Renderer.h">Device&#x2F;Graphics&#x2F;Renderer.h</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Renderer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Renderer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Submit</span><span class="params">(<span class="type">const</span> Ref&lt;RenderCommand&gt;&amp; command)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DGEX_API <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，并不是所有场景都对绘制顺序有要求，如果绘制对象已经有序的话，排序反而会影响性能，因此我们可以实现 <code>DirectRender</code> 和 <code>OrderedRenderer</code> 两种封装，分别针对无序和有序的场景，具体声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Device/Graphics/RendererImpl.h">Device&#x2F;Graphics&#x2F;RendererImpl.h</a>。</p>
<p>最后，可以提供如下的方法供用户创建渲染器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RendererProperties</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> Ordered;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DGEX_API Ref&lt;Renderer&gt; <span class="title">CreateRenderer</span><span class="params">(<span class="type">const</span> RendererProperties&amp; properties)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由于可以选择使用不同的渲染器实现绘制，因此需要提供函数选择当前活跃的渲染器，以及获取当前的渲染器。当然，我们有默认的渲染器，用 <code>nullptr</code> 代表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">SetCurrentRenderer</span><span class="params">(<span class="type">const</span> Ref&lt;Renderer&gt;&amp; renderer = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="function">DGEX_API Ref&lt;Renderer&gt; <span class="title">GetCurrentRenderer</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>更进一步，我们也可以借鉴 <code>std::lock_guard</code> 的方式实现作用域内渲染器的使用和恢复。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USE_RENDERER(renderer) RendererGuard __dgex_renderer_guard((renderer))</span></span><br></pre></td></tr></table></figure>

<h2 id="绘制目标"><a href="#绘制目标" class="headerlink" title="绘制目标"></a>绘制目标</h2><p>刚刚提到了，绘图设备是绘图接口中的重要概念，是我们绘制的目标，类似“画板”（Canvas）。在 SDL 中，绘图设备本质是一块缓冲区，当然，屏幕是一块特殊的缓冲区。一块缓冲区对应一个 <code>SDL_Texture</code> 对象，而屏幕由 <code>nullptr</code> 代表。对于图片，在加载时可以选择是否可作为绘制目标。在 DungineX 中，为了简化，默认所有加载的图片都可作为绘制目标。</p>
<h3 id="缓冲区封装"><a href="#缓冲区封装" class="headerlink" title="缓冲区封装"></a>缓冲区封装</h3><p>我们的缓冲区封装如下，为了避免不必要的资源管理问题，我们禁止了 <code>Texture</code> 对象的拷贝和移动操作，从而所有 <code>SDL_Texture</code> 都有相应的 <code>Texture</code> 管理。而且，我们这里并不使用 RAII，因为 <code>Texture</code> 对象并不实际拥有 <code>SDL_Texture</code>，所以在析构时也不进行释放，而是通过 <code>Destroy</code> 方法显式地释放。具体的声明见  <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Texture.h">Renderer&#x2F;Texture.h</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Texture</span><span class="params">(SDL_Texture* texture)</span></span>;</span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> Texture&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Texture</span>(Texture&amp;&amp; other) <span class="keyword">noexcept</span> = <span class="keyword">delete</span>;</span><br><span class="line">    Texture&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Texture&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Texture&amp; <span class="keyword">operator</span>=(Texture&amp;&amp; other) <span class="keyword">noexcept</span> = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Texture</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DGEX_API <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">DGEX_API <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SDL_Texture* <span class="title">GetNativeTexture</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SDL_Texture* _texture;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div class="note warning flat"><p>这里我们不使用 RAII 还有另一个原因，就是析构函数的调用时机。全局变量会在 <code>main</code> 函数结束后析构，因此相应的析构函数会在 SDL 以及日志系统卸载之后触发。Texture 的释放不是问题，因为 SDL 卸载时即会清理所有资源，不会有 dobule-free 的问题。主要是其他系统，比如日志系统的卸载会使得析构函数无法输出日志。</p>
</div>

<h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>为了提高绘制效率，SDL 默认对屏幕使用双缓冲机制。也就是说，所有向屏幕的绘制操作都首先在 Back Buffer 完成，当每帧更新屏幕时，才将 Back Buffer 里的内容绘制到 Front Buffer，也就是屏幕。因此每帧都需要手动调用 <code>SDL_RenderPresent</code> 更新屏幕画面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">FlushDevice</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="绘图属性"><a href="#绘图属性" class="headerlink" title="绘图属性"></a>绘图属性</h2><p>在绘制过程中，我们需要控制特定的属性，比如线条和填充颜色，字体大小等，因此也需要提供相应的函数。在 DungineX 中，我们提供五种绘制属性。</p>
<ul>
<li>清除颜色</li>
<li>线条颜色</li>
<li>填充颜色</li>
<li>字体颜色</li>
<li>字体大小</li>
</ul>
<p>其中主要涉及颜色，因此有必要单独进行说明。</p>
<h3 id="颜色常量"><a href="#颜色常量" class="headerlink" title="颜色常量"></a>颜色常量</h3><p>颜色结构体的定义位于 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Renderer/Color.h">Renderer&#x2F;Color.h</a>，这里采用整数存储颜色信息。用 <code>uint8_t</code> 存储各个颜色能够稍微节省一些内存，但可能计算的时候会有一定的溢出风险，需要注意扩展。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> R, G, B, A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于颜色，我们希望能够预先定义一些色彩常量，于是会遇到另一个问题，就是如何在 DLL 中导出变量。对于这个问题，你可以先回顾一下之前提到的这篇讨论：[Why&#x2F;when is __declspec( dllimport ) not needed?](Why&#x2F;when is __declspec( dllimport ) not needed?)。</p>
<p>对于函数和变量的导出是有一定区别的，因此我们需要重新定义 <code>DGEX_API</code>，并为变量导出定义新的 <code>DGEX_DATA</code>，具体见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Defines.h">Defines.h</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DGEX_EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DGEX_ENGINE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_API  __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_DATA __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_DATA __declspec(dllimport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DGEX_ENGINE</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_DATA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DGEX_EXPORT</span></span></span><br></pre></td></tr></table></figure>

<p>在有定义 <code>DGEX_EXPORT</code> 时，DungineX 需要对函数和变量进行导出，而用户只需要导入变量，因此有必要区分 <code>DGEX_API</code> 和 <code>DGEX_DATA</code>。最终，我们可以正常地定义静态常量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    DGEX_DATA <span class="type">static</span> <span class="type">const</span> Color Black;</span><br><span class="line">    DGEX_DATA <span class="type">static</span> <span class="type">const</span> Color Blue;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h2><p>下面，我们终于来到了图形设备接口的定义，首先是图形的绘制。最基本的，我们需要实现点、线和矩形的绘制。</p>
<div class="note info flat"><p>这时你可能注意到了，自始至终我都没有提到任何涉及曲线的绘制，比如圆形。因为对于渲染引擎，或是 GPU 来说，它们擅长线段或是三角形的绘制，因此曲线通常通过特定的算法绘制，比如使用多边形拟合。这并不是特别必要的功能，因此暂时不进行实现。</p>
</div>

<p>具体地，我们有这几个函数进行原生图形的绘制。之前也解释了，我们希望能够控制绘制顺序，因此接口中都有 <code>z</code> 来进行排序。此外，绘制时的颜色属性通过之前提到的绘图属性控制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawFilledRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<div class="note info flat"><p>如果你之前使用过 Windows GDI，你可能还会问，为什么没有控制线条粗细的选项？因为一般来说，游戏依赖于图片资源，或专门的 Shader，很少直接使用线条绘制，所以没有必要提供更改线条粗细的选项。如果确实需要，可以交给客户端实现。</p>
</div>

<h3 id="图像绘制-1"><a href="#图像绘制-1" class="headerlink" title="图像绘制"></a>图像绘制</h3><p>图像在之前的<a href="#%E7%BB%98%E5%88%B6%E7%9B%AE%E6%A0%87">绘制目标</a>中已经介绍过了。在 DungineX 中，图片和绘制目标相同，都是 <code>Texture</code>，其绘制接口如下，在指定位置绘制图片。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawTexture</span><span class="params">(<span class="type">const</span> Ref&lt;Texture&gt;&amp; texture, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>游戏中需要大量绘制图片，对绘制也有很多要求，包括图像的缩放、旋转、透明度等，让用户一个一个指定略显麻烦。因此，这里我们可以采用 Builder 的思想，并使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fluent_interface">Fluent API</a> 实现复杂的图像绘制指令。</p>
<div class="note info flat"><p>这里略有炫技倾向。</p>
</div>

<p>具体地，我们可以声明相应的 Fluent API 对象，实现对各个属性的修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DrawTextureClause</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DrawTextureClause</span>(<span class="type">const</span> Ref&lt;Texture&gt;&amp; texture, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z);</span><br><span class="line">    </span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">Alpha</span><span class="params">(<span class="type">uint8_t</span> alpha)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">Anchor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">FlipX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">FlipY</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">Rotate</span><span class="params">(<span class="type">float</span> degree)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">Scale</span><span class="params">(<span class="type">float</span> scale)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">DGEX_API <span class="type">void</span> <span class="title">Submit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ref&lt;TextureRenderCommandBuilder&gt; _builder;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DGEX_API DrawTextureClause <span class="title">DrawTextureBegin</span><span class="params">(<span class="type">const</span> Ref&lt;Texture&gt;&amp; texture, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>最后，既然要绘制图片，那么肯定得先实现加载。在 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Renderer/Texture.h">Renderer&#x2F;Texture.h</a> 中，我们声明 <code>LoadTexture</code> 函数，加载指定路径的图片，其中使用 SDL3_image 的 <code>IMG_Load</code> 方法实现图片加载。在 SDL 中，为了与渲染引擎解耦，纹理首先被加载为 <code>SDL_Surface</code>，而后被处理为具体渲染引擎支持的 <code>SDL_Texture</code>。转换后，<code>SDL_Surface</code> 不再被使用，因此可以被销毁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL3_image/SDL_image.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Ref&lt;Texture&gt; <span class="title">LoadTexture</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDL_Surface* surface = <span class="built_in">IMG_Load</span>(path.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (!surface)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DGEX_CORE_ERROR</span>(<span class="string">&quot;Failed to load texture: &#123;0&#125;, &#123;1&#125;&quot;</span>, path, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_Texture* texture = <span class="built_in">SDL_CreateTextureFromSurface</span>(<span class="built_in">GetNativeRenderer</span>(), surface);</span><br><span class="line">    <span class="built_in">SDL_DestroySurface</span>(surface);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DGEX_CORE_INFO</span>(<span class="string">&quot;Loaded texture: &#123;0&#125;&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateRef</span>&lt;Texture&gt;(texture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文本绘制"><a href="#文本绘制" class="headerlink" title="文本绘制"></a>文本绘制</h2><p>最后，对于任何应用程序，都少不了文字。然而，文本绘制一直都是非常具有挑战性的。一方面，文字形状看起来就很难绘制，另一方面排版也不容易。在 SDL 中，文本最终也是转化为图片进行绘制，需要首先加载字体文件，然后将所需要的文本渲染为 Texture。</p>
<p>然而，绘制的文本往往经常发生变化，每一帧都从字体中加载 Texture 显然会十分影响性能。因此一个通用的做法，是首先将字体中所有字符都首先渲染成图片，然后在绘制时通过拼接单个字符的图像实现文本的绘制。这一方法的名称很有意思，为字体创建 Atlas，即一大张包含所有字符的图片，其中每个字符对应一个 Glyph，在绘制时从中找到对应字符的 Glyph 进行输出。例如，一个 Atlas 图片如下，不过一般会根据字符间距进行压缩，不会像这个例子一样有这么大的间距。</p>
<p><img src="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/atlas.png" alt="atlas"></p>
<p>很可惜，SDL，以及 SDL_ttf 都不提供生成 Atlas 的功能，更不支持高效的字符绘制，因此需要我们手动实现。不过，已经有 <a target="_blank" rel="noopener" href="https://github.com/grimfang4/SDL_FontCache">grimfang4&#x2F;SDL_FontCache</a> 为我们实现了这一功能。然而，这个仓库已经“年久失修”，只支持 SDL 2，所以还是需要一定修改，具体的改动见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/SDL_FontCache">Lord-Turmoil&#x2F;SDL_FontCache</a>，使其支持 SDL 3。当然，我们需要在 Vendor 中引入 SDL_FontCache。</p>
<h3 id="字体封装"><a href="#字体封装" class="headerlink" title="字体封装"></a>字体封装</h3><p>SDL_FontCache 进一步对 SDL_ttf 中的 <code>SDL_Font</code> 进行封装，提供 <code>FC_Font</code>。这里确实没有必要让用户真的看到这个 <code>FC_Font</code>，也不希望用户间接引入 <code>FC_FontCache.h</code>，所以这里采用了 pImpl 的方式，对 <code>FC_Font</code> 进行了隐藏。具体的字体封装见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Font.h">Renderer&#x2F;Font.h</a>，接受 <code>TTF_Font</code>，并在构造函数中使用 <code>FC_LoadFontFromTTF</code> 加载 <code>FC_Font</code>，并作为 <code>_impl</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(TTF_Font* font)</span></span>;</span><br><span class="line">    ~<span class="built_in">Font</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DGEX_API <span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TTF_Font* <span class="title">GetNativeFont</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetImpl</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TTF_Font* _font;</span><br><span class="line">    <span class="type">void</span>* _impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="字体加载"><a href="#字体加载" class="headerlink" title="字体加载"></a>字体加载</h3><p>由于字体封装中，我们还是接收 <code>TTF_Font</code>，所以字体加载时使用 SDL_ttf 的加载方式即可。和图片加载不同的是，我们不希望相同的字体被多次加载，因此需要记录加载了哪些字体，以及我们需要有一个默认字体。</p>
<p>对于前者，我们可以通过 <code>std::unordered_map</code> 轻松实现，根据 <code>TTF_GetFontFamilyName</code> 得到的字体名称判断即可。对于后者，由于我们目前只针对 Windows 系统，因此可以在 C:&#x2F;Windows&#x2F;Fonts 下挑一个字体，这里选择的是 C:&#x2F;Windows&#x2F;Fonts&#x2F;Arial.ttf。当然，在用户指定加载字体时，如果指定路径不存在，也可以 Fallback 到系统目录下找一找。</p>
<div class="note warning flat"><p>这时，细心的你可能会发现，我们没有考虑字体的变形，比如加粗、倾斜等，这些特性我们可以留到之后再实现。</p>
</div>

<h3 id="文本绘制-1"><a href="#文本绘制-1" class="headerlink" title="文本绘制"></a>文本绘制</h3><p>最后，是文本绘制，这里主要是字体大小的处理。字体大小是通过缩放实现的，我们可以在加载时选择一个标准，比如 100pt，随后根据用户指定的大小进行缩放。</p>
<p>最终，我们提供两个绘制函数，一个在指定位置绘制单行文本，另一个在指定矩形内绘制多行文本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> : <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">&#123;</span><br><span class="line">    DGEX_TextAlignLeft   = <span class="built_in">DGEX_BIT</span>(<span class="number">0</span>),</span><br><span class="line">    DGEX_TextAlignRight  = <span class="built_in">DGEX_BIT</span>(<span class="number">1</span>),</span><br><span class="line">    DGEX_TextAlignCenter = <span class="built_in">DGEX_BIT</span>(<span class="number">2</span>),</span><br><span class="line">    DGEX_TextOverflow    = <span class="built_in">DGEX_BIT</span>(<span class="number">3</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawText</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">int</span> x, <span class="type">int</span> y, TextFlags flags)</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawTextArea</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, TextFlags flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="模块初始化接口"><a href="#模块初始化接口" class="headerlink" title="模块初始化接口"></a>模块初始化接口</h2><p>最后，我们可以为所有的绘图设备提供统一的初始化接口，具体见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Graphics.h">Device&#x2F;Graphics&#x2F;Graphics.h</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">dgex_error_t</span> <span class="title">InitGraphics</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DestroyGraphics</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>用户只需要调用统一的接口，即可实现整个绘图模块的加载和卸载。</p>
<hr>
<h1 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h1><p>接下来，我们需要思考如何向用户提供我们的功能，或者说，用户应该如何使用 DungineX。这里我们需要有两方面的考量与权衡，一方面，我们希望 DungineX 足够简单，用户可以尽可能少地调用接口；另一方面，我们还是想保持足够的灵活性，允许用户实现更多自定义的行为。</p>
<h2 id="主函数封装"><a href="#主函数封装" class="headerlink" title="主函数封装"></a>主函数封装</h2><p>首先，依然是我们自定义的 <code>main</code> 函数。和上一章相比，没有什么变化，因为我们将所有操作都交给了用户。不过呢，我们还是默认进行了日志系统的加载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Preamble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log::<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DGEX_CORE_CRITICAL</span>(<span class="string">&quot;Made with DungineX &quot;</span> DGEX_VERSION_STRING);</span><br><span class="line">    <span class="built_in">DGEX_CORE_CRITICAL</span>(<span class="string">&quot;Copyright (C) New Desire Studios &quot;</span> DGEX_YEAR_STRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DgeXMainImpl</span><span class="params">(CommandLineArgs args, DgeXMainEntry entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Preamble</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">entry</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="note info flat"><p>或许有一些 Annoying，但是由于很多组件都依赖日志输出，所以我们不得不提前进行加载。之后可以实现默认的空日志，从而可以完全不输出日志。</p>
</div>

<p>如果采用这种方式，那么需要由用户手动管理组件的注册，以及游戏的循环。目前，我们只有图形设备，因此用户的 <code>main</code> 函数如下，需要由用户手动完成各个步骤，但是会更加方便。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DgeX/EntryPoint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(CommandLineArgs args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitGrahpics</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// process input</span></span><br><span class="line">        <span class="comment">// update</span></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DestroyGraphics</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning flat"><p>由于之前提到的问题，因为我们暂时没有提供事件处理接口，因此暂时没有具体示例。</p>
</div>

<h2 id="基于回调的程序入口"><a href="#基于回调的程序入口" class="headerlink" title="基于回调的程序入口"></a>基于回调的程序入口</h2><p>当然，对于游戏，很多时候我们只关注游戏逻辑，因此我们可以参考 SDL 的方式，提供回调，从而简化游戏的编写。具体地，我们可以有如下几个回调。</p>
<ul>
<li><code>OnInit</code>：在 DungineX 各个组件（除了日志）加载之前调用。</li>
<li><code>OnStart</code>：在 DungineX 各个组件加载后、游戏主循环开始前调用。</li>
<li><code>OnUpdate</code>：每帧更新时调用。</li>
<li><code>OnEvent</code>：接收到事件后调用。</li>
<li><code>OnExit</code>：主循环结束后、DungineX 卸载前调用。</li>
</ul>
<p>于是，我们最终的入口如下，具体见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/EntryPoint.h">Device&#x2F;EntryPoint.h</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DGEX_USE_CALLBACKS</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DgeXMainImplWithCallbacks</span>(&#123; argc, argv &#125;, DgeXOnInit, DgeXOnStart, DgeXOnUpdate, DgeXOnEvent, DgeXOnExit);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DgeXMainImpl</span>(&#123; argc, argv &#125;, DgeXMain);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>DgeXDgeXMainImplWithCallbacks</code> 中，我们的流程伪代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">OnInit</span>();</span><br><span class="line">    <span class="comment">// DungineX init</span></span><br><span class="line">    <span class="built_in">OnStart</span>();</span><br><span class="line">    <span class="comment">// Main loop</span></span><br><span class="line">    loop &#123;</span><br><span class="line">        <span class="built_in">OnEvent</span>();</span><br><span class="line">        <span class="built_in">OnUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">OnExit</span>();</span><br><span class="line">    <span class="comment">// DungineX exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照我们最初的设想，实际上希望用户以 <code>Interface</code> 的形式提供游戏的每一个界面，方便界面的切换和统一管理，从而更新和事件都由 <code>Interface</code> 对象处理，于是不再需要 <code>OnUpdate</code> 和 <code>OnEvent</code> 两个回调。在之后我们实现 <code>Interface</code> 和 <code>Application</code> 时，会进一步进行完善。</p>
<p>目前在 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/tree/0.1.1/Demo/HelloThere">Demo&#x2F;HelloThere</a> 下有一个示例，可以进行参考，具体执行效果如下。</p>
<img src="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/image-20250704200028406.png" alt="image-20250704200028406" style="zoom:67%;">

<hr>
<h1 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h1><p>在下一章中，我们将实现事件处理，并继续完善游戏主循环。有了事件之后，我们的游戏引擎便可以说是初具雏形了。ᓚᘏᗢ</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://tonys-studio.top">Tony Lewis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/">https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Game-Engine-0-to-1/">Game Engine 0 to 1</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/05/06.jpeg" onerror="onerror=null;src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Getting Started With Coq</div></div><div class="info-2"><div class="info-item-1">Introduction to Coq and environment setup</div></div></div></a><a class="pagination-related" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/24/10.jpeg" onerror="onerror=null;src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Game Engine 0 to 1 (01): It Starts Now</div></div><div class="info-2"><div class="info-item-1">Game Engine Series 01: Project setup</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/Game-Engine-0-to-1-00-Nothing-s-Here/" title="Game Engine 0 to 1 (00): Nothing&#39;s Here"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/01/04.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> May. 27th, 2025 - 19:05:29</div><div class="info-item-2">Game Engine 0 to 1 (00): Nothing&#39;s Here</div></div><div class="info-2"><div class="info-item-1">Game Engine Series 00: Prologue</div></div></div></a><a class="pagination-related" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/24/10.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jun. 1st, 2025 - 14:45:32</div><div class="info-item-2">Game Engine 0 to 1 (01): It Starts Now</div></div><div class="info-2"><div class="info-item-1">Game Engine Series 01: Project setup</div></div></div></a><a class="pagination-related" href="/posts/C-Object-Lifecycle/" title="C++ Object Lifecycle"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/06/02.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Oct. 1st, 2024 - 17:07:53</div><div class="info-item-2">C++ Object Lifecycle</div></div><div class="info-2"><div class="info-item-1">Breakdown of C++ object lifecycle to wipe out all your doubts</div></div></div></a><a class="pagination-related" href="/posts/Configure-VS-for-Non-MSVC-Projects/" title="Configure Visual Studio for Non-MSVC Projects"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/02/08.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Apr. 27th, 2023 - 09:13:37</div><div class="info-item-2">Configure Visual Studio for Non-MSVC Projects</div></div><div class="info-2"><div class="info-item-1">Configure VS IntelliSense for GCC</div></div></div></a><a class="pagination-related" href="/posts/Dungeon/" title="Dungeon"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/posts/Dungeon.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jan. 4th, 2023 - 21:45:04</div><div class="info-item-2">Dungeon</div></div><div class="info-2"><div class="info-item-1">A rogue-like game developed with EasyX and FMOD in C++.</div></div></div></a><a class="pagination-related" href="/posts/Inter-Process-Communication/" title="Inter-Process Communication"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/03/02.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jan. 4th, 2023 - 17:56:03</div><div class="info-item-2">Inter-Process Communication</div></div><div class="info-2"><div class="info-item-1">Chapter Seven - Inter Process Communication</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/avatar.png" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/missing.gif'" alt="avatar"/></div><div class="author-info-name">Tony Lewis</div><div class="author-info-description">Do or do not. There is no try.</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">93</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">84</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">40</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Lord-Turmoil" target="_blank" title="Github"><i class="fa-brands fa-github"></i></a><a class="social-icon" href="mailto:swift-phantom@outlook.com" target="_blank" title="Email"><i class="fa-solid fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/2030942344" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">It won't be long before the armies of the Republic track us here.<br>You can visit this site at both:<li><a href="http://blog.tonys-studio.top/" target="_blank">Main Site</a></li><li><a href="https://lord-turmoil.github.io/" target="_blank">Github Mirror Site</a></li></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1"><span class="toc-text">设备抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1%EF%BC%9F"><span class="toc-text">为什么需要设备抽象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1"><span class="toc-text">图形设备抽象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Infrastructure"><span class="toc-text">Infrastructure</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%88Type-Alias%EF%BC%89"><span class="toc-text">类型别名（Type Alias）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%EF%BC%88Logging%EF%BC%89"><span class="toc-text">日志输出（Logging）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="toc-text">日志配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E9%87%8C%E9%9C%80%E8%A6%81-DGEX-API%EF%BC%9F"><span class="toc-text">哪里需要 DGEX_API？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logger"><span class="toc-text">Logger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assertion"><span class="toc-text">Assertion</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pit-Fall"><span class="toc-text">Pit Fall</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%91%E5%AE%9A"><span class="toc-text">上下文绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entry-Point"><span class="toc-text">Entry Point</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA"><span class="toc-text">窗口创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%B1%9E%E6%80%A7"><span class="toc-text">窗口属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA-1"><span class="toc-text">窗口创建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E6%8E%A5%E5%8F%A3"><span class="toc-text">绘图接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-text">创建渲染器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F"><span class="toc-text">绘制顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-text">绘制指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%99%A8%E5%B0%81%E8%A3%85"><span class="toc-text">渲染器封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%9B%AE%E6%A0%87"><span class="toc-text">绘制目标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B0%81%E8%A3%85"><span class="toc-text">缓冲区封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-text">双缓冲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E5%B1%9E%E6%80%A7"><span class="toc-text">绘图属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E5%B8%B8%E9%87%8F"><span class="toc-text">颜色常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6"><span class="toc-text">图像绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6-1"><span class="toc-text">图像绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD"><span class="toc-text">图片加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BB%98%E5%88%B6"><span class="toc-text">文本绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E5%B0%81%E8%A3%85"><span class="toc-text">字体封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E5%8A%A0%E8%BD%BD"><span class="toc-text">字体加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BB%98%E5%88%B6-1"><span class="toc-text">文本绘制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-text">模块初始化接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3"><span class="toc-text">程序入口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85"><span class="toc-text">主函数封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3"><span class="toc-text">基于回调的程序入口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E5%91%8A"><span class="toc-text">预告</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Music-Notation-with-Avid-Sibelius-Ultimate/" title="Music Notation With Avid Sibelius Ultimate"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/posts/Music-Notation-with-Avid-Sibelius-Ultimate.jpg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Music Notation With Avid Sibelius Ultimate"/></a><div class="content"><a class="title" href="/posts/Music-Notation-with-Avid-Sibelius-Ultimate/" title="Music Notation With Avid Sibelius Ultimate">Music Notation With Avid Sibelius Ultimate</a><time datetime="2025-09-03T04:34:54.000Z" title="Created Sep. 3rd, 2025 - 12:34:54 12:34:54">Sep. 3rd, 2025 - 12:34:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/05/06.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Getting Started With Coq"/></a><div class="content"><a class="title" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq">Getting Started With Coq</a><time datetime="2025-08-08T04:30:12.000Z" title="Created Aug. 8th, 2025 - 12:30:12 12:30:12">Aug. 8th, 2025 - 12:30:12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/" title="Game Engine 0 to 1 (02): Something on the Screen"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/12/05.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Game Engine 0 to 1 (02): Something on the Screen"/></a><div class="content"><a class="title" href="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/" title="Game Engine 0 to 1 (02): Something on the Screen">Game Engine 0 to 1 (02): Something on the Screen</a><time datetime="2025-07-04T12:07:57.000Z" title="Created Jul. 4th, 2025 - 20:07:57 20:07:57">Jul. 4th, 2025 - 20:07:57</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/24/10.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Game Engine 0 to 1 (01): It Starts Now"/></a><div class="content"><a class="title" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now">Game Engine 0 to 1 (01): It Starts Now</a><time datetime="2025-06-01T06:45:32.000Z" title="Created Jun. 1st, 2025 - 14:45:32 14:45:32">Jun. 1st, 2025 - 14:45:32</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Game-Engine-0-to-1-00-Nothing-s-Here/" title="Game Engine 0 to 1 (00): Nothing's Here"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/01/04.jpeg" onerror="this.onerror=null;this.src='https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png'" alt="Game Engine 0 to 1 (00): Nothing's Here"/></a><div class="content"><a class="title" href="/posts/Game-Engine-0-to-1-00-Nothing-s-Here/" title="Game Engine 0 to 1 (00): Nothing's Here">Game Engine 0 to 1 (00): Nothing's Here</a><time datetime="2025-05-27T11:05:29.000Z" title="Created May. 27th, 2025 - 19:05:29 19:05:29">May. 27th, 2025 - 19:05:29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/12/05.jpeg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Tony Lewis</span></div><div class="footer_custom_text">No bird soars too high if he soars on his own wings</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'forest'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://comment.tonys-studio.top',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client@2/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client@2/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/custom.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Anything you would like to search?🔍" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="Framework Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo%205.4.2-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="Theme Butterfly" title=""><img src="https://img.shields.io/badge/Theme-Butterfly%205.4.3-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="All articles in this blog are licensed under CC BY-NC-SA 4.0 unless stating additionally." title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><!-- hexo injector body_end end --></body></html>