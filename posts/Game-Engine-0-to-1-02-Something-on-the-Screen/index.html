<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Game Engine 0 to 1 (02): Something on the Screen | TONY'S STUDIO</title><meta name="author" content="Tony Lewis"><meta name="copyright" content="Tony Lewis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#300303"><meta name="description" content="Game Engine Series 02: Graphics Device"><meta property="og:type" content="article"><meta property="og:title" content="Game Engine 0 to 1 (02): Something on the Screen"><meta property="og:url" content="https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/"><meta property="og:site_name" content="TONY&#39;S STUDIO"><meta property="og:description" content="Game Engine Series 02: Graphics Device"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/06/08.jpeg"><meta property="article:published_time" content="2025-07-04T12:07:57.000Z"><meta property="article:modified_time" content="2025-11-11T14:22:44.317Z"><meta property="article:author" content="Tony Lewis"><meta property="article:tag" content="C&#x2F;C++"><meta property="article:tag" content="Game Engine 0 to 1"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/06/08.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Game Engine 0 to 1 (02): Something on the Screen",
  "url": "https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/",
  "image": "https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/06/08.jpeg",
  "datePublished": "2025-07-04T12:07:57.000Z",
  "dateModified": "2025-11-11T14:22:44.317Z",
  "author": [
    {
      "@type": "Person",
      "name": "Tony Lewis",
      "url": "https://www.tonys-studio.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/favicon.svg"><link rel="canonical" href="https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#300303")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","undefined")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",()=>{void 0===t.get("theme")&&(e.matches?o():a())})}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>var _hmt=_hmt||[];!function(){var t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?68629f5da0a0c3347b896920fbf164b5";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(t,a)}(),btf.addGlobalFn("pjaxComplete",()=>{_hmt.push(["_trackPageview",window.location.pathname])},"baidu_analytics")</script><script>!function(t,e,n,c,r,s,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(s=e.createElement(c)).async=1,s.src="https://www.clarity.ms/tag/sthrplbt7c",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(s,a)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:3,unescape:!1,pagination:{enable:!0,hitsPerPage:8},languages:{hits_empty:"No results found for: ${query}",hits_stats:"${hits} articles found"}},translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"Copy Successful",error:"Copy Failed",noSupport:"Browser Not Supported"},relativeDate:{homepage:!1,post:!1},runtime:"days",dateSuffix:{just:"Just now",min:"minutes ago",hour:"hours ago",day:"days ago",month:"months ago"},copyright:{limitCount:256,languages:{author:"Author: Tony Lewis",link:"Link: ",source:"Source: TONY'S STUDIO",info:"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},lightbox:"fancybox",Snackbar:{chs_to_cht:"You have switched to Traditional Chinese",cht_to_chs:"You have switched to Simplified Chinese",day_to_night:"You have switched to Dark Mode",night_to_day:"You have switched to Light Mode",bgLight:"#871798",bgDark:"#C81025",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"Load More"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Game Engine 0 to 1 (02): Something on the Screen",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="/static/custom.css"><meta name="generator" content="Hexo 8.1.1"></head><body><script>window.paceOptions={restartOnPushState:!1},btf.addGlobalFn("pjaxSend",()=>{Pace.restart()},"pace_restart")</script><link rel="stylesheet" href="/static/barber-shop.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image:url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/background.png)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/avatar.png" onerror='this.onerror=null,this.src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/missing.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">87</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">40</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-jedi fa-beat"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/06/08.jpeg)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/logo.svg" alt="Logo"><span class="site-name">TONY'S STUDIO</span></a><a class="nav-page-title" href="/"><span class="site-name">Game Engine 0 to 1 (02): Something on the Screen</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-newspaper"></i><span> Posts</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-jedi fa-beat"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Game Engine 0 to 1 (02): Something on the Screen</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-04T12:07:57.000Z" title="Created Jul. 4th, 2025 - 20:07:57 20:07:57">Jul. 4th, 2025 - 20:07:57</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-11T14:22:44.317Z" title="Updated Nov. 11th, 2025 - 22:22:44 22:22:44">Nov. 11th, 2025 - 22:22:44</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Game-Hobby/">Game &amp; Hobby</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Game-Hobby/Game-Development/">Game Development</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>28mins</span></span><span class="post-meta-separator">|</span><span data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span class="waline-pageview-count" data-path="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/#post-comment"><span class="waline-comment-count" data-path="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><html><head></head><body><p style="text-align:center;font-size:x-large"><b>[02] Something on the Screen</b></p><p style="text-align:center"><i>“Got this love, I can feel,</i><br><i>And I know, yes for sure, it is real.</i><br><i>And it feels as though I've seen your face a thousand times...”</i></p><p style="text-align:right"><i>— Michael Jackson (This is it)</i></p><div class="note orange icon-padding flat"><i class="note-icon fas fa-list-check"></i><p>DungineX 目前还在开发中，你可以在这里查看当前的开发任务列表：<a target="_blank" rel="noopener" href="https://swift-phantom.notion.site/29509166825e80d0b9d2fe4ebec60754?v=29509166825e806c8a21000ce1b3c9ce&amp;source=copy_link">DungineX TODO</a>。</p></div><div class="note green icon-padding flat"><i class="note-icon fas fa-tag"></i><p>你可以在 <a href="/tags/Game-Engine-0-to-1/">Game Engine 0 to 1</a> 标签下浏览该系列的所有文章。</p></div><div class="note purple icon-padding flat"><i class="note-icon fab fa-github"></i><p>DungineX 完全开源，代码托管在 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX">GitHub</a>，本章对应<a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/tree/0.1.1">🏷️0.1.1</a>。</p></div><p>在本章中，主要介绍 DungineX 中图形设备的设计与实现，从如何创建窗口到实现各种绘制功能。不过，作为一个从零开始的项目，还有很多基础组件有待实现，例如日志、工具方法等，因此也会对这些主题进行穿插介绍。</p><div class="note warning flat"><p>由于一些别扭的翻译原因，Texture 可以翻译为纹理，也指图片。所以在本文中提到纹理和图片均指 Texture。</p></div><hr><h1 id="设备抽象"><a href="#设备抽象" class="headerlink" title="设备抽象"></a>设备抽象</h1><p>首先，我想有必要回顾一下设备（Device）的概念。</p><p>什么是设备？我们都知道，根据冯·诺依曼架构，计算机分为控制器、运算器、存储、输入和输出五个部分，而设备主要就指的是其中的输入和输出。对于游戏，通常的输出设备就是屏幕和扬声器，而输入设备就是鼠标和键盘。游戏需要能够显示画面，播放声音，接收玩家的操作，因此设备接口对于游戏编写十分重要。</p><h2 id="为什么需要设备抽象？"><a href="#为什么需要设备抽象？" class="headerlink" title="为什么需要设备抽象？"></a>为什么需要设备抽象？</h2><p>这个问题的答案非常显然，当然是为了方便使用。设备通常与硬件相关，而不同的硬件设备有不同的接口，由用户直接调用这些接口十分不便。这里有一张图非常生动形象，虽然是用来描述操作系统的，但是在这里同样合适。设备抽象要做的，就是屏蔽底层硬件细节，为用户提供统一、易用的接口。</p><img src="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/image-20250625231138135.png" alt="image-20250625231138135" style="zoom:50%"><p>虽然现有的一些库，比如 <a target="_blank" rel="noopener" href="https://www.libsdl.org/">SDL3</a>、<a target="_blank" rel="noopener" href="https://www.fmod.com/">FMOD</a> 等已经提供了必要的抽象，从而可以相对简单的实现对应功能， 但是这些接口毕竟不是我们自己实现的，如果不进行抽象，则很难与我们的项目整合在一起。此外，这些接口的设计往往考虑到通用性，因此在游戏开发场景下可能还需进一步的封装。</p><p>具体地，设备抽象能够在以下两点为我们提供便利：</p><ul><li><strong>屏蔽底层细节</strong>。底层的组件往往考虑到通用性，相对晦涩复杂，因此在设备抽象中，可以根据具体的使用场景提供简化的 API。</li><li>**提高灵活性。**部分情况下，同一个服务可以有不同的实现，比如对于音频设备，我们可以使用 SDL3，也可以使用 FMOD，甚至可以禁用音频设备。有了设备抽象的存在，用户将使用统一的接口访问底层的设备支持，而不用关注具体的实现。这是否让你想到了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a>？</li><li>**方便模块间通信。**这个就很容易理解了，根据我们自定义的抽象，可以更方便地实现各个组件的相互调用。</li></ul><h2 id="图形设备抽象"><a href="#图形设备抽象" class="headerlink" title="图形设备抽象"></a>图形设备抽象</h2><p>当然，这次的主题还是图形设备。对于图形设备，其主要负责窗口的管理，以及图形绘制。</p><div class="note info flat"><p>为什么窗口会和绘制耦合在一起，原因在于，由于绘制缓冲区的存在，绘制指令往往依赖于图形上下文，而这一上下文通常绑定在一个窗口实例上。例如，在 SDL 中，渲染器（Renderer）依赖于当前窗口。</p></div><p>对于图形绘制，可以进一步分为三类对象的绘制，或者说渲染（Render）。</p><ul><li>原生（Primitive）图形，也就是像素点、线，矩形等。</li><li>纹理（Texture），其实也就是绘制图片，因此这里也会涉及图片的加载。</li><li>文本（Text），这个比较特别，相对更加 tricky，之后会具体介绍。</li></ul><p>提供这些接口的抽象后，用户就可以实现最基础绘制，在屏幕上显示有趣的图像了。</p><hr><h1 id="Infrastructure"><a href="#Infrastructure" class="headerlink" title="Infrastructure"></a>Infrastructure</h1><p>不过，在我们开始实现图形设备接口之前，还需要一些准备工作。对于一个较大规模的项目来说，通常需要一些“基础设施”的支持，比如 C/C++ 很喜欢的类型别名，日志输出等。</p><h2 id="类型别名（Type-Alias）"><a href="#类型别名（Type-Alias）" class="headerlink" title="类型别名（Type Alias）"></a>类型别名（Type Alias）</h2><p>可能是 C/C++ 支持这一特性的缘故吧，几乎所有项目都会有这一操作，一方面是为了可移植性，另一方面也是一种偷懒的方式吧。这也是我喜欢 C，尤其是 C++ 的原因之一，因为其提供了其他语言无法媲美的灵活性。</p><p>内存漏洞是 C++ 常常被诟病的问题，然而，现代的 C++ 已经有很完善的机制避免相关问题了，也就是智能指针 <code>std::shared_ptr</code>。通过将代码中的裸指针替换为智能指针，便能很大程度上避免，甚至消除内存相关问题。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Ref = std::shared_ptr&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">constexpr</span> Ref&lt;T&gt; <span class="title">CreateRef</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="note info flat"><p>这一类型定义方法来自 <a target="_blank" rel="noopener" href="https://github.com/TheCherno">The Cherno</a> 的 <a target="_blank" rel="noopener" href="https://github.com/TheCherno/Hazel">Hazel</a>。</p></div><p>除了智能指针封装外，目前还没有遇到其他特别的类型，具体可以参考 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Utils/Types.h">Utils\Types.h</a>。当然，我们可以为基本类型定义别名，比如 <code>uint32</code> 等，但其实头文件 <code>cstdint</code> 已经提供了相关定义了。</p><h2 id="日志输出（Logging）"><a href="#日志输出（Logging）" class="headerlink" title="日志输出（Logging）"></a>日志输出（Logging）</h2><p>尽管是自己亲手编写的程序，你是否时常会苦恼于难以定位错误，或是追踪程序的执行状态？对于这一问题，为程序添加日志输出是一个非常好的解决方案。在 DungineX 中，我们选择 <a target="_blank" rel="noopener" href="https://github.com/gabime/spdlog">spdlog</a> 作为日志库，一方面是因为其灵活性与高性能，另一方面是因为我对它相对更加熟悉。</p><p>本节中，我简单介绍 DungineX 中的日志系统，具体的日志系统声明可参考 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Utils/Log.h">Utils/Log.h</a> 和 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Utils/Log.cpp">Utils/Log.cpp</a>。</p><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>日志输出通常有以下几个配置选项：</p><ul><li>名称（Name），最好可以通过名称区分不同组件的日志。</li><li>等级（Level），用来区分不同重要程度的日志消息。</li><li>目标（Sink），日志输出到哪里，控制台还是文件，还是多个目标。</li><li>格式（Format），具体的日志消息是什么样子的。</li></ul><p>因此，我们的日志配置如下，即 <code>LoggerSpecification</code>。注意到这里使用 <code>std::initializer_list</code> 来避免显式传入 <code>std::vector</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LoggerSinkSpecification</span></span><br><span class="line">{</span><br><span class="line">    std::string Path;</span><br><span class="line">    std::string Pattern;</span><br><span class="line">    </span><br><span class="line">    <span class="function">DGEX_API <span class="title">LoggerSinkSpecification</span><span class="params">(std::string path)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API <span class="title">LoggerSinkSpecification</span><span class="params">(std::string path, std::string pattern)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoggerSpecification</span></span><br><span class="line">{</span><br><span class="line">    std::string Name;</span><br><span class="line">    LogLevel Level;</span><br><span class="line">    std::vector&lt;LoggerSinkSpecification&gt; Sinks;</span><br><span class="line">    </span><br><span class="line">    <span class="function">DGEX_API <span class="title">LoggerSpecification</span><span class="params">(std::string name, LogLevel level, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 std::initializer_list&lt;LoggerSinkSpecification&gt; sinks)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="note success flat"><p>或许你看到这里大写的成员名称有些惊讶，这一风格来自我编写 C# 代码的经验，来标识 public 成员。</p></div><h3 id="哪里需要-DGEX-API？"><a href="#哪里需要-DGEX-API？" class="headerlink" title="哪里需要 DGEX_API？"></a>哪里需要 <code>DGEX_API</code>？</h3><p>虽然有些突兀，但是我们在这里第一次遇到这一问题。在 <code>LoggerSpecification</code> 中，我们只给构造函数添加了 <code>DGEX_API</code>，即 <code>__declspec(dllexport)</code>，那为什么不给成员变量也添加呢，或是更激进一些，直接为整个结构体添加这一属性呢？</p><div class="note info flat"><p>你可以自行尝试给整个结构体添加 <code>DGEX_API</code>，看看会发生什么。</p></div><p>这里的原因在于，<code>__declspec(dllexport)</code> 类似于 DLL 编写者与使用者之前的一个“约定”，即被标记的声明应当保持兼容，也就是说，即使更新了 DLL，客户端仍然能够以相同的方式调用被标记的“东西”。</p><p>那么问题就来了，对于函数，本质就是一个固定大小的地址，那么我们只要保证提供这个地址就可以。而对于成员变量，就不只是地址了，还有大小。成员大小取决于类型， 因此为了遵守“约定”，对应的类型也需要被标记，于是你会遇到 <code>__declspec(dllexport)</code> 传播的问题。对于自定义的类型，比如 <code>LogLevel</code>，可以直接标记，而对于像 <code>std::string</code> 这样的标准库类型，由于其并不提供 DLL 导出，所以我们也没办法实现导出。不过，由于成员最终会变成地址偏移量，而头文件是提供给客户端的，因此用户可以获得相应的类型的声明，只要偏移量和大小一致，便能正确实现运行时的访问。</p><p>因此，我们只需要标记需要导出的函数即可。当然，不一定所有函数都需要导出，因此可以有选择地隐藏部分接口。不过，如果用户选择静态链接，那么其实还是可以使用所有接口，最根本的隐藏接口的方法还是将其放在私有头文件目录下，但是会相对麻烦些。</p><div class="note warning flat"><p>目前，我们认为只有 DLL 暴露的接口为公开接口。</p></div><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>接下来，是日志系统。恰当的日志能够让我们高效地排查程序中的问题，并且观测程序的执行状态。DungineX 中的 Logger 声明如下。我们刚刚说过，通常不应该，也不能导出整个结构体或类，而是导出其中对外暴露的方法，所以这里只导出对应的日志输出方法。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> LoggerSpecification&amp; specification);</span><br><span class="line">    ~<span class="built_in">Logger</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt; <span class="function">DGEX_API <span class="type">void</span> <span class="title">Debug</span><span class="params">(spdlog::<span class="type">format_string_t</span>&lt;Args...&gt; fmt, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        _impl-&gt;<span class="built_in">debug</span>(fmt, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">    Ref&lt;spdlog::logger&gt; _impl;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="note success flat"><p>从 Logger 中，已经可以看到些许 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> 的影子了，即在构造函数中完成资源的初始化。</p></div><p>我们不希望用户随便创建 Logger，所以没有用 <code>DGEX_API</code> 标记构造和析构函数，而是将 Logger 的注册和获取放在了静态类 <code>Log</code> 中。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DGEX_API <span class="type">static</span> Ref&lt;Logger&gt; <span class="title">GetLogger</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API <span class="type">static</span> Ref&lt;Logger&gt; <span class="title">RegisterLogger</span><span class="params">(<span class="type">const</span> LoggerSpecification&amp; specification)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> std::unordered_map&lt;std::string, Ref&lt;Logger&gt;&gt; _sLoggers;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>最后，我们可以用宏实现简化的日志输出。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _DGEX_LOGGER(NAME) DGEX Log::GetLogger(NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_LOG_DEBUG(NAME, ...) _DGEX_LOGGER(NAME)-&gt;Debug(__VA_ARGS__)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Assertion"><a href="#Assertion" class="headerlink" title="Assertion"></a>Assertion</h2><p>对于 C/C++ 这样没有运行时检查的语言来说，有时需要我们手动进行一些边界或条件检查。标准库提供的 <code>assert</code> 功能过于简单，我们尤其希望能够将 assert 的结果输出到日志，因此我们的 assert 可以和日志系统相结合。具体的 assert 实现见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Utils/Assert.h">Utils/Assert.h</a>。</p><hr><h1 id="Pit-Fall"><a href="#Pit-Fall" class="headerlink" title="Pit Fall"></a>Pit Fall</h1><p>有了基础设施之后，我们就可以正式开始编码了。由于是第一次使用 SDL3，而且是一个比较特殊的场景（将 SDL3 打包进 DLL），遇到了一些问题，也花了很多功夫解决。在开始前，对相关问题进行说明。</p><h2 id="上下文绑定"><a href="#上下文绑定" class="headerlink" title="上下文绑定"></a>上下文绑定</h2><p>这一问题确实很奇怪，对于 DungineX，我们将 SDL3 打包进引擎，再以 DLL 的形式提供给用户，看似没什么问题，但是却会使 SDL 的上下文管理出问题。</p><p>这一问题具体表现为，如果客户端只通过 DungineX 的接口调用 SDL，那么一切正常。而一旦客户端直接调用了 SDL 中标记只能在主线程中调用的函数，那么程序就会挂起（Hang）。</p><p>按理说 DLL 和程序运行在同一线程，但是可能因为 DLL 的加载，SDL 的上下文初始化机制，以及大量使用锁进行同步，导致二者不能共享同一上下文吧，所以导致了死锁。</p><div class="note danger flat"><p>具体原因还有待进一步探究。</p></div><h2 id="Entry-Point"><a href="#Entry-Point" class="headerlink" title="Entry Point"></a>Entry Point</h2><p>刚刚提到了上下文绑定的问题，客户端不能直接调用 SDL 的函数，所以也就不能使用 SDL 提供的生命周期回调了。因此需要我们自行实现程序的入口。</p><p><a href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/">上一章</a>中的入口实现还很简单，本章中进行了更新，会在之后具体介绍。</p><hr><h1 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h1><p>下面，我们正式开始图形设备的编写。首先，自然是创建一个窗口，具体代码见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Window.h">Device/Graphics/Window.h</a> 和 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Device/Graphics/Window.cpp">Device/Graphics/Window.cpp</a>。</p><h2 id="窗口属性"><a href="#窗口属性" class="headerlink" title="窗口属性"></a>窗口属性</h2><p>对于一个窗口，其主要的属性很简单，无非是标题、大小以及一些选项，比如是否可缩放、是否全屏等。对此，我们可以定义如下的窗口属性。类似的，我们只将构造函数标记为 <code>DGEX_API</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> WindowFlags = <span class="type">unsigned</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> : <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">{</span><br><span class="line">    DgexWindowDefault            = <span class="number">0</span>,</span><br><span class="line">    DgexWindowAlwaysOnTop        = <span class="built_in">DGEX_BIT</span>(<span class="number">0</span>),    <span class="comment">// always on top</span></span><br><span class="line">    DgexWindowBorderless         = <span class="built_in">DGEX_BIT</span>(<span class="number">1</span>),    <span class="comment">// launch as borderless window</span></span><br><span class="line">    DgexWindowFullScreen         = <span class="built_in">DGEX_BIT</span>(<span class="number">2</span>),    <span class="comment">// launch in fullscreen</span></span><br><span class="line">    DgexWindowResizable          = <span class="built_in">DGEX_BIT</span>(<span class="number">3</span>),    <span class="comment">// allow window to resize</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WindowProperties</span></span><br><span class="line">{</span><br><span class="line">    std::string Title;</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    WindowFlags Flags;</span><br><span class="line"></span><br><span class="line">    <span class="function">DGEX_API <span class="title">WindowProperties</span><span class="params">(std::string title, <span class="type">int</span> width, <span class="type">int</span> height, WindowFlags flags)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>当然，窗口的创建由 DungineX 完成，那么为了使用户能够自定义窗口属性，可以提供这样一个函数，在创建窗口前，由用户提供自定义的窗口属性。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">SetWindowPropertiesHint</span><span class="params">(<span class="type">const</span> WindowProperties&amp; properties)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="窗口创建-1"><a href="#窗口创建-1" class="headerlink" title="窗口创建"></a>窗口创建</h2><p>一个程序可能不止一个窗口，不过对于游戏来说，一个窗口足矣。因此，我们可以通过这种方式访问具体的窗口实例，当然这个接口不对用户暴露。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SDL_Window* sNativeWindow = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SDL_Window* <span class="title">GetNativeWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">DGEX_ASSERT</span>(sNativeWindow, <span class="string">"Window not initialized"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sNativeWindow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="note info flat"><p>为了实现对 SDL 接口彻底的封装，我们不应当向用户暴露任何 SDL 的函数和类型。</p></div><p>对于窗口的创建，SDL 已经封装得很好了，我们只需要将我们自定义的窗口选项转化为 SDL 支持的窗口选项，并调用 <code>SDL_CreateWindow</code> 即可。同时，这里也展示了日志的使用。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">dgex_error_t</span> <span class="title">InitWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SDL_Window* window = <span class="built_in">SDL_CreateWindow</span>(</span><br><span class="line">        sWindowPropertiesHint.Title.<span class="built_in">c_str</span>(),</span><br><span class="line">        sWindowPropertiesHint.Width,</span><br><span class="line">        sWindowPropertiesHint.Height,</span><br><span class="line">        <span class="built_in">GetSdlWindowFlags</span>(sWindowPropertiesHint.Flags));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">DGEX_CORE_ERROR</span>(<span class="string">"Failed to create window: {0}"</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">        <span class="keyword">return</span> DGEX_ERROR_WINDOW_INIT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sNativeWindow = window;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line">    <span class="built_in">SDL_GetWindowSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">"Window size: {0}x{1}"</span>, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SDL_ShowWindow</span>(sNativeWindow);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">"Window initialized"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DGEX_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="note info flat"><p>关于日志输出的格式，可以参考 <a target="_blank" rel="noopener" href="https://github.com/gabime/spdlog/wiki">spdlog 的官方文档</a>。</p></div><p>现在，我们在调用 <code>InitWindow</code> 函数后，就可以得到一个窗口了。</p><div class="note info flat"><p>目前，在得到图形窗口时，控制台窗口依然存在，这是因为我们最终链接构建的是控制台应用。想要去掉控制台，可以之后切换至 Windows 窗口应用，使用 <code>WinMain</code> 代替 <code>main</code>。</p></div><hr><h1 id="绘图接口"><a href="#绘图接口" class="headerlink" title="绘图接口"></a>绘图接口</h1><p>此时，我们已经能够得到一个黑黑的窗口，接下来，就可以在其中实现图形的绘制了。对于游戏来说，我们通常需要实现以下几个绘图功能：</p><ul><li>在屏幕上绘制点、线等图形，以及图片和文字。</li><li>支持图像的缩放、旋转等效果。</li><li>在指定目标实现绘制。</li></ul><p>总结起来，你需要了解以下几点概念。</p><ul><li>绘制目标：本质是一块缓冲区，可以是屏幕，也可以是图片（纹理）。</li><li>绘图属性：比如线条颜色、文字大小等。</li><li>图像绘制：在绘图设备上实现绘制，包括原生图形，图片以及文字。</li></ul><p>这些概念看起来很简单<del>，实际一点也不复杂</del>，SDL 已经提供了相应的封装，因此我们的任务很轻松。具体的绘制接口声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Renderer/RenderApi.h">Renderer/RenderApi.h</a>。</p><h2 id="创建渲染器"><a href="#创建渲染器" class="headerlink" title="创建渲染器"></a>创建渲染器</h2><p>SDL 的所有绘制操作都由 <code>SDL_Renderer</code> 完成，其绑定在当前窗口上，从而实现该窗口的绘制和渲染任务。在我们创建好窗口后，就可以初始化渲染器了。具体的渲染器初始化如下，与窗口类似，使用 <code>sNativeRenderer</code> 维护渲染器实例，便于最终释放资源。为了更好地展示 SDL 的功能，在初始化渲染器时，列出了所有可用的 Renderer Driver，可以看到 SDL 支持 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/direct3d">Direct3D</a>，<a target="_blank" rel="noopener" href="https://www.opengl.org/">OpenGL</a>，<a target="_blank" rel="noopener" href="https://www.vulkan.org/">Vulkan</a> 等多个渲染后端。当然，这里我们最终让 SDL 自行选择。由于按照字典序选择， 因此很可能会选择 Direct3D。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">dgex_error_t</span> <span class="title">InitRenderer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">SDL_GetNumRenderDrivers</span>();</span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">"Available render drivers: {0}"</span>, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* name = <span class="built_in">SDL_GetRenderDriver</span>(i);</span><br><span class="line">        <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">"    Render driver {0}: {1}"</span>, i, name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SDL_Renderer* renderer = <span class="built_in">SDL_CreateRenderer</span>(<span class="built_in">GetNativeWindow</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!renderer)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">DGEX_CORE_ERROR</span>(<span class="string">"Failed to initialize renderer: {0}"</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">        <span class="keyword">return</span> DGEX_ERROR_RENDERER_INIT;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SDL_PropertiesID props = <span class="built_in">SDL_GetRendererProperties</span>(renderer);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="built_in">SDL_GetStringProperty</span>(props, SDL_PROP_RENDERER_NAME_STRING, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">"Using renderer: {0}"</span>, name ? name : <span class="string">"Unknown"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SDL_SetRenderVSync</span>(renderer, <span class="number">-1</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">DGEX_CORE_WARN</span>(<span class="string">"VSync not supported: {0}"</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sNativeRenderer = renderer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DGEX_CORE_DEBUG</span>(<span class="string">"Renderer initialized"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DGEX_SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><div class="note warning flat"><p>很奇怪，在我本地 SDL 始终无法支持 VSync，即使更换渲染后端还是无果，不过由于已经使用了双缓冲，是否使用 VSync 其实并不重要。</p></div><h3 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h3><p>DungineX 是一个 2D 游戏引擎，虽然是 2D，但是在处理伪 3D 场景时仍存在遮挡问题。在 OpenGL 中，我们可以指定顶点的三维坐标，由 OpenGL 决定渲染的遮挡关系。而 SDL 只支持 2D 绘制，不存在 Z 轴来支持深度检测，因此只能用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Painter's_algorithm">画家算法（Painter‘s Algorithm）</a>实现正确的图像遮挡关系。</p><p>虽然画家算法很简单，但是需要时刻关注对象的位置关系，会为用户带来很多麻烦。因此，我们可以对渲染器进行封装，从而支持一个虚拟的 Z 轴。</p><h3 id="绘制指令"><a href="#绘制指令" class="headerlink" title="绘制指令"></a>绘制指令</h3><p>既然 SDL 不支持 Z 轴，那么我们可以抽象出支持 Z 轴的绘制指令。通过 <code>RenderCommand</code> 将具体的绘制动作封装起来，就可以实现对 RenderCommand 的排序，进而支持绘制的排序，具体的声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Device/Graphics/RenderCommand.h">Device/Graphics/RenderCommand.h</a>。由于用户无需了解 RenderCommand，所以我们可以将其放在私有目录下。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderCommand</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RenderCommand</span>(<span class="type">int</span> order);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetOrder</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Apply</span><span class="params">(SDL_Renderer* renderer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _order;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>具体地，我们可以进一步实现具体的绘制指令，具体的声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Renderer/RenderCommandImpl.h">Renderer/RenderCommandImpl.h</a>。</p><p>首先，是原生绘制指令的封装，将绘制操作打包成匿名函数，从而可以在排序后进行调用。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NativeRenderCommand</span> <span class="keyword">final</span> : <span class="keyword">public</span> RenderCommand</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">using</span> RenderAction = std::function&lt;<span class="built_in">void</span>(SDL_Renderer*)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NativeRenderCommand</span>(<span class="type">const</span> RenderAction&amp; action, <span class="type">int</span> order);</span><br><span class="line">    ~<span class="built_in">NativeRenderCommand</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(SDL_Renderer* renderer)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Ref&lt;NativeRenderCommand&gt; <span class="title">Create</span><span class="params">(<span class="type">const</span> RenderAction&amp; action, <span class="type">int</span> order = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RenderAction _action;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其实这一个封装就足够了，但是由于图像绘制参数实在是太多，不仅有 <code>Texture</code> 对象，还有位置、缩放、旋转、翻转、锚点等，所以也值得我们为它封装一个绘制指令。<code>TextureRenderCommand</code> 相对复杂，具体见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Renderer/RenderCommandImpl.h">Renderer/RenderCommandImpl.h</a>。</p><h3 id="渲染器封装"><a href="#渲染器封装" class="headerlink" title="渲染器封装"></a>渲染器封装</h3><p>有了绘制指令后，我们要做的就是让渲染器识别我们的虚拟 Z 轴。渲染器的封装如下，支持提交绘制指令，以及执行绘制。同理，这里我们不希望用户直接创建 <code>Renderer</code>，或是提交绘制指令，因此只暴露 <code>Render()</code> 方法，详细声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Renderer.h">Device/Graphics/Renderer.h</a>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Renderer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Renderer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Submit</span><span class="params">(<span class="type">const</span> Ref&lt;RenderCommand&gt;&amp; command)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DGEX_API <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>当然，并不是所有场景都对绘制顺序有要求，如果绘制对象已经有序的话，排序反而会影响性能，因此我们可以实现 <code>DirectRender</code> 和 <code>OrderedRenderer</code> 两种封装，分别针对无序和有序的场景，具体声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/src/Device/Graphics/RendererImpl.h">Device/Graphics/RendererImpl.h</a>。</p><p>最后，可以提供如下的方法供用户创建渲染器。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RendererProperties</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">bool</span> Ordered;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">DGEX_API Ref&lt;Renderer&gt; <span class="title">CreateRenderer</span><span class="params">(<span class="type">const</span> RendererProperties&amp; properties)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>由于可以选择使用不同的渲染器实现绘制，因此需要提供函数选择当前活跃的渲染器，以及获取当前的渲染器。当然，我们有默认的渲染器，用 <code>nullptr</code> 代表。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">SetCurrentRenderer</span><span class="params">(<span class="type">const</span> Ref&lt;Renderer&gt;&amp; renderer = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="function">DGEX_API Ref&lt;Renderer&gt; <span class="title">GetCurrentRenderer</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>更进一步，我们也可以借鉴 <code>std::lock_guard</code> 的方式实现作用域内渲染器的使用和恢复。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USE_RENDERER(renderer) RendererGuard __dgex_renderer_guard((renderer))</span></span><br></pre></td></tr></tbody></table></figure><h2 id="绘制目标"><a href="#绘制目标" class="headerlink" title="绘制目标"></a>绘制目标</h2><p>刚刚提到了，绘图设备是绘图接口中的重要概念，是我们绘制的目标，类似“画板”（Canvas）。在 SDL 中，绘图设备本质是一块缓冲区，当然，屏幕是一块特殊的缓冲区。一块缓冲区对应一个 <code>SDL_Texture</code> 对象，而屏幕由 <code>nullptr</code> 代表。对于图片，在加载时可以选择是否可作为绘制目标。在 DungineX 中，为了简化，默认所有加载的图片都可作为绘制目标。</p><h3 id="缓冲区封装"><a href="#缓冲区封装" class="headerlink" title="缓冲区封装"></a>缓冲区封装</h3><p>我们的缓冲区封装如下，为了避免不必要的资源管理问题，我们禁止了 <code>Texture</code> 对象的拷贝和移动操作，从而所有 <code>SDL_Texture</code> 都有相应的 <code>Texture</code> 管理。而且，我们这里并不使用 RAII，因为 <code>Texture</code> 对象并不实际拥有 <code>SDL_Texture</code>，所以在析构时也不进行释放，而是通过 <code>Destroy</code> 方法显式地释放。具体的声明见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Texture.h">Renderer/Texture.h</a>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Texture</span><span class="params">(SDL_Texture* texture)</span></span>;</span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> Texture&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Texture</span>(Texture&amp;&amp; other) <span class="keyword">noexcept</span> = <span class="keyword">delete</span>;</span><br><span class="line">    Texture&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Texture&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Texture&amp; <span class="keyword">operator</span>=(Texture&amp;&amp; other) <span class="keyword">noexcept</span> = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Texture</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DGEX_API <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">DGEX_API <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SDL_Texture* <span class="title">GetNativeTexture</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SDL_Texture* _texture;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><div class="note warning flat"><p>这里我们不使用 RAII 还有另一个原因，就是析构函数的调用时机。全局变量会在 <code>main</code> 函数结束后析构，因此相应的析构函数会在 SDL 以及日志系统卸载之后触发。Texture 的释放不是问题，因为 SDL 卸载时即会清理所有资源，不会有 dobule-free 的问题。主要是其他系统，比如日志系统的卸载会使得析构函数无法输出日志。</p></div><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>为了提高绘制效率，SDL 默认对屏幕使用双缓冲机制。也就是说，所有向屏幕的绘制操作都首先在 Back Buffer 完成，当每帧更新屏幕时，才将 Back Buffer 里的内容绘制到 Front Buffer，也就是屏幕。因此每帧都需要手动调用 <code>SDL_RenderPresent</code> 更新屏幕画面。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">FlushDevice</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="绘图属性"><a href="#绘图属性" class="headerlink" title="绘图属性"></a>绘图属性</h2><p>在绘制过程中，我们需要控制特定的属性，比如线条和填充颜色，字体大小等，因此也需要提供相应的函数。在 DungineX 中，我们提供五种绘制属性。</p><ul><li>清除颜色</li><li>线条颜色</li><li>填充颜色</li><li>字体颜色</li><li>字体大小</li></ul><p>其中主要涉及颜色，因此有必要单独进行说明。</p><h3 id="颜色常量"><a href="#颜色常量" class="headerlink" title="颜色常量"></a>颜色常量</h3><p>颜色结构体的定义位于 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Renderer/Color.h">Renderer/Color.h</a>，这里采用整数存储颜色信息。用 <code>uint8_t</code> 存储各个颜色能够稍微节省一些内存，但可能计算的时候会有一定的溢出风险，需要注意扩展。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> R, G, B, A;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于颜色，我们希望能够预先定义一些色彩常量，于是会遇到另一个问题，就是如何在 DLL 中导出变量。对于这个问题，你可以先回顾一下之前提到的这篇讨论：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4489441/why-when-is-declspec-dllimport-not-needed">Why/when is __declspec( dllimport ) not needed?</a>。</p><p>对于函数和变量的导出是有一定区别的，因此我们需要重新定义 <code>DGEX_API</code>，并为变量导出定义新的 <code>DGEX_DATA</code>，具体见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Defines.h">Defines.h</a>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DGEX_EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DGEX_ENGINE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_API  __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_DATA __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_DATA __declspec(dllimport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DGEX_ENGINE</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DGEX_DATA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DGEX_EXPORT</span></span></span><br></pre></td></tr></tbody></table></figure><p>在有定义 <code>DGEX_EXPORT</code> 时，DungineX 需要对函数和变量进行导出，而用户只需要导入变量，因此有必要区分 <code>DGEX_API</code> 和 <code>DGEX_DATA</code>。最终，我们可以正常地定义静态常量。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span></span><br><span class="line">{</span><br><span class="line">    DGEX_DATA <span class="type">static</span> <span class="type">const</span> Color Black;</span><br><span class="line">    DGEX_DATA <span class="type">static</span> <span class="type">const</span> Color Blue;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h2><p>下面，我们终于来到了图形设备接口的定义，首先是图形的绘制。最基本的，我们需要实现点、线和矩形的绘制。</p><div class="note info flat"><p>这时你可能注意到了，自始至终我都没有提到任何涉及曲线的绘制，比如圆形。因为对于渲染引擎，或是 GPU 来说，它们擅长线段或是三角形的绘制，因此曲线通常通过特定的算法绘制，比如使用多边形拟合。这并不是特别必要的功能，因此暂时不进行实现。</p></div><p>具体地，我们有这几个函数进行原生图形的绘制。之前也解释了，我们希望能够控制绘制顺序，因此接口中都有 <code>z</code> 来进行排序。此外，绘制时的颜色属性通过之前提到的绘图属性控制。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawFilledRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><div class="note info flat"><p>如果你之前使用过 Windows GDI，你可能还会问，为什么没有控制线条粗细的选项？因为一般来说，游戏依赖于图片资源，或专门的 Shader，很少直接使用线条绘制，所以没有必要提供更改线条粗细的选项。如果确实需要，可以交给客户端实现。</p></div><h3 id="图像绘制-1"><a href="#图像绘制-1" class="headerlink" title="图像绘制"></a>图像绘制</h3><p>图像在之前的<a href="#%E7%BB%98%E5%88%B6%E7%9B%AE%E6%A0%87">绘制目标</a>中已经介绍过了。在 DungineX 中，图片和绘制目标相同，都是 <code>Texture</code>，其绘制接口如下，在指定位置绘制图片。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawTexture</span><span class="params">(<span class="type">const</span> Ref&lt;Texture&gt;&amp; texture, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>游戏中需要大量绘制图片，对绘制也有很多要求，包括图像的缩放、旋转、透明度等，让用户一个一个指定略显麻烦。因此，这里我们可以采用 Builder 的思想，并使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fluent_interface">Fluent API</a> 实现复杂的图像绘制指令。</p><div class="note info flat"><p>这里略有炫技倾向。</p></div><p>具体地，我们可以声明相应的 Fluent API 对象，实现对各个属性的修改。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DrawTextureClause</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DrawTextureClause</span>(<span class="type">const</span> Ref&lt;Texture&gt;&amp; texture, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z);</span><br><span class="line">    </span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">Alpha</span><span class="params">(<span class="type">uint8_t</span> alpha)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">Anchor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">FlipX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">FlipY</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">Rotate</span><span class="params">(<span class="type">float</span> degree)</span></span>;</span><br><span class="line">    <span class="function">DGEX_API DrawTextureClause <span class="title">Scale</span><span class="params">(<span class="type">float</span> scale)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">DGEX_API <span class="type">void</span> <span class="title">Submit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ref&lt;TextureRenderCommandBuilder&gt; _builder;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">DGEX_API DrawTextureClause <span class="title">DrawTextureBegin</span><span class="params">(<span class="type">const</span> Ref&lt;Texture&gt;&amp; texture, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>最后，既然要绘制图片，那么肯定得先实现加载。在 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Renderer/Texture.h">Renderer/Texture.h</a> 中，我们声明 <code>LoadTexture</code> 函数，加载指定路径的图片，其中使用 SDL3_image 的 <code>IMG_Load</code> 方法实现图片加载。在 SDL 中，为了与渲染引擎解耦，纹理首先被加载为 <code>SDL_Surface</code>，而后被处理为具体渲染引擎支持的 <code>SDL_Texture</code>。转换后，<code>SDL_Surface</code> 不再被使用，因此可以被销毁。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL3_image/SDL_image.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Ref&lt;Texture&gt; <span class="title">LoadTexture</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SDL_Surface* surface = <span class="built_in">IMG_Load</span>(path.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (!surface)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">DGEX_CORE_ERROR</span>(<span class="string">"Failed to load texture: {0}, {1}"</span>, path, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">    SDL_Texture* texture = <span class="built_in">SDL_CreateTextureFromSurface</span>(<span class="built_in">GetNativeRenderer</span>(), surface);</span><br><span class="line">    <span class="built_in">SDL_DestroySurface</span>(surface);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DGEX_CORE_INFO</span>(<span class="string">"Loaded texture: {0}"</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateRef</span>&lt;Texture&gt;(texture);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="文本绘制"><a href="#文本绘制" class="headerlink" title="文本绘制"></a>文本绘制</h2><p>最后，对于任何应用程序，都少不了文字。然而，文本绘制一直都是非常具有挑战性的。一方面，文字形状看起来就很难绘制，另一方面排版也不容易。在 SDL 中，文本最终也是转化为图片进行绘制，需要首先加载字体文件，然后将所需要的文本渲染为 Texture。</p><p>然而，绘制的文本往往经常发生变化，每一帧都从字体中加载 Texture 显然会十分影响性能。因此一个通用的做法，是首先将字体中所有字符都首先渲染成图片，然后在绘制时通过拼接单个字符的图像实现文本的绘制。这一方法的名称很有意思，为字体创建 Atlas，即一大张包含所有字符的图片，其中每个字符对应一个 Glyph，在绘制时从中找到对应字符的 Glyph 进行输出。例如，一个 Atlas 图片如下，不过一般会根据字符间距进行压缩，不会像这个例子一样有这么大的间距。</p><p><img src="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/atlas.png" alt="atlas"></p><p>很可惜，SDL，以及 SDL_ttf 都不提供生成 Atlas 的功能，更不支持高效的字符绘制，因此需要我们手动实现。不过，已经有 <a target="_blank" rel="noopener" href="https://github.com/grimfang4/SDL_FontCache">grimfang4/SDL_FontCache</a> 为我们实现了这一功能。然而，这个仓库已经“年久失修”，只支持 SDL 2，所以还是需要一定修改，具体的改动见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/SDL_FontCache">Lord-Turmoil/SDL_FontCache</a>，使其支持 SDL 3。当然，我们需要在 Vendor 中引入 SDL_FontCache。</p><h3 id="字体封装"><a href="#字体封装" class="headerlink" title="字体封装"></a>字体封装</h3><p>SDL_FontCache 进一步对 SDL_ttf 中的 <code>SDL_Font</code> 进行封装，提供 <code>FC_Font</code>。这里确实没有必要让用户真的看到这个 <code>FC_Font</code>，也不希望用户间接引入 <code>FC_FontCache.h</code>，所以这里采用了 pImpl 的方式，对 <code>FC_Font</code> 进行了隐藏。具体的字体封装见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Font.h">Renderer/Font.h</a>，接受 <code>TTF_Font</code>，并在构造函数中使用 <code>FC_LoadFontFromTTF</code> 加载 <code>FC_Font</code>，并作为 <code>_impl</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(TTF_Font* font)</span></span>;</span><br><span class="line">    ~<span class="built_in">Font</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DGEX_API <span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TTF_Font* <span class="title">GetNativeFont</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">GetImpl</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TTF_Font* _font;</span><br><span class="line">    <span class="type">void</span>* _impl;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="字体加载"><a href="#字体加载" class="headerlink" title="字体加载"></a>字体加载</h3><p>由于字体封装中，我们还是接收 <code>TTF_Font</code>，所以字体加载时使用 SDL_ttf 的加载方式即可。和图片加载不同的是，我们不希望相同的字体被多次加载，因此需要记录加载了哪些字体，以及我们需要有一个默认字体。</p><p>对于前者，我们可以通过 <code>std::unordered_map</code> 轻松实现，根据 <code>TTF_GetFontFamilyName</code> 得到的字体名称判断即可。对于后者，由于我们目前只针对 Windows 系统，因此可以在 C:/Windows/Fonts 下挑一个字体，这里选择的是 C:/Windows/Fonts/Arial.ttf。当然，在用户指定加载字体时，如果指定路径不存在，也可以 Fallback 到系统目录下找一找。</p><div class="note warning flat"><p>这时，细心的你可能会发现，我们没有考虑字体的变形，比如加粗、倾斜等，这些特性我们可以留到之后再实现。</p></div><h3 id="文本绘制-1"><a href="#文本绘制-1" class="headerlink" title="文本绘制"></a>文本绘制</h3><p>最后，是文本绘制，这里主要是字体大小的处理。字体大小是通过缩放实现的，我们可以在加载时选择一个标准，比如 100pt，随后根据用户指定的大小进行缩放。</p><p>最终，我们提供两个绘制函数，一个在指定位置绘制单行文本，另一个在指定矩形内绘制多行文本。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> : <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">{</span><br><span class="line">    DGEX_TextAlignLeft   = <span class="built_in">DGEX_BIT</span>(<span class="number">0</span>),</span><br><span class="line">    DGEX_TextAlignRight  = <span class="built_in">DGEX_BIT</span>(<span class="number">1</span>),</span><br><span class="line">    DGEX_TextAlignCenter = <span class="built_in">DGEX_BIT</span>(<span class="number">2</span>),</span><br><span class="line">    DGEX_TextOverflow    = <span class="built_in">DGEX_BIT</span>(<span class="number">3</span>)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawText</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">int</span> x, <span class="type">int</span> y, TextFlags flags)</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DrawTextArea</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, TextFlags flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="模块初始化接口"><a href="#模块初始化接口" class="headerlink" title="模块初始化接口"></a>模块初始化接口</h2><p>最后，我们可以为所有的绘图设备提供统一的初始化接口，具体见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/Device/Graphics/Graphics.h">Device/Graphics/Graphics.h</a>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DGEX_API <span class="type">dgex_error_t</span> <span class="title">InitGraphics</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">DGEX_API <span class="type">void</span> <span class="title">DestroyGraphics</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>用户只需要调用统一的接口，即可实现整个绘图模块的加载和卸载。</p><hr><h1 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h1><p>接下来，我们需要思考如何向用户提供我们的功能，或者说，用户应该如何使用 DungineX。这里我们需要有两方面的考量与权衡，一方面，我们希望 DungineX 足够简单，用户可以尽可能少地调用接口；另一方面，我们还是想保持足够的灵活性，允许用户实现更多自定义的行为。</p><h2 id="主函数封装"><a href="#主函数封装" class="headerlink" title="主函数封装"></a>主函数封装</h2><p>首先，依然是我们自定义的 <code>main</code> 函数。和上一章相比，没有什么变化，因为我们将所有操作都交给了用户。不过呢，我们还是默认进行了日志系统的加载。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Preamble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Log::<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DGEX_CORE_CRITICAL</span>(<span class="string">"Made with DungineX "</span> DGEX_VERSION_STRING);</span><br><span class="line">    <span class="built_in">DGEX_CORE_CRITICAL</span>(<span class="string">"Copyright (C) New Desire Studios "</span> DGEX_YEAR_STRING);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DgeXMainImpl</span><span class="params">(CommandLineArgs args, DgeXMainEntry entry)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">Preamble</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">entry</span>(args);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><div class="note info flat"><p>或许有一些 Annoying，但是由于很多组件都依赖日志输出，所以我们不得不提前进行加载。之后可以实现默认的空日志，从而可以完全不输出日志。</p></div><p>如果采用这种方式，那么需要由用户手动管理组件的注册，以及游戏的循环。目前，我们只有图形设备，因此用户的 <code>main</code> 函数如下，需要由用户手动完成各个步骤，但是会更加方便。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"DgeX/EntryPoint.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(CommandLineArgs args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">InitGrahpics</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// process input</span></span><br><span class="line">        <span class="comment">// update</span></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DestroyGraphics</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="note warning flat"><p>由于之前提到的问题，因为我们暂时没有提供事件处理接口，因此暂时没有具体示例。</p></div><h2 id="基于回调的程序入口"><a href="#基于回调的程序入口" class="headerlink" title="基于回调的程序入口"></a>基于回调的程序入口</h2><p>当然，对于游戏，很多时候我们只关注游戏逻辑，因此我们可以参考 SDL 的方式，提供回调，从而简化游戏的编写。具体地，我们可以有如下几个回调。</p><ul><li><code>OnInit</code>：在 DungineX 各个组件（除了日志）加载之前调用。</li><li><code>OnStart</code>：在 DungineX 各个组件加载后、游戏主循环开始前调用。</li><li><code>OnUpdate</code>：每帧更新时调用。</li><li><code>OnEvent</code>：接收到事件后调用。</li><li><code>OnExit</code>：主循环结束后、DungineX 卸载前调用。</li></ul><p>于是，我们最终的入口如下，具体见 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/blob/0.1.1/DungineX/include/DgeX/EntryPoint.h">Device/EntryPoint.h</a>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DGEX_USE_CALLBACKS</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DgeXMainImplWithCallbacks</span>({ argc, argv }, DgeXOnInit, DgeXOnStart, DgeXOnUpdate, DgeXOnEvent, DgeXOnExit);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DgeXMainImpl</span>({ argc, argv }, DgeXMain);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 <code>DgeXDgeXMainImplWithCallbacks</code> 中，我们的流程伪代码如下。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="built_in">OnInit</span>();</span><br><span class="line">    <span class="comment">// DungineX init</span></span><br><span class="line">    <span class="built_in">OnStart</span>();</span><br><span class="line">    <span class="comment">// Main loop</span></span><br><span class="line">    loop {</span><br><span class="line">        <span class="built_in">OnEvent</span>();</span><br><span class="line">        <span class="built_in">OnUpdate</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">OnExit</span>();</span><br><span class="line">    <span class="comment">// DungineX exit</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>按照我们最初的设想，实际上希望用户以 <code>Interface</code> 的形式提供游戏的每一个界面，方便界面的切换和统一管理，从而更新和事件都由 <code>Interface</code> 对象处理，于是不再需要 <code>OnUpdate</code> 和 <code>OnEvent</code> 两个回调。在之后我们实现 <code>Interface</code> 和 <code>Application</code> 时，会进一步进行完善。</p><p>目前在 <a target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil/DungineX/tree/0.1.1/Demo/HelloThere">Demo/HelloThere</a> 下有一个示例，可以进行参考，具体执行效果如下。</p><img src="/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/image-20250704200028406.png" alt="image-20250704200028406" style="zoom:67%"><hr><h1 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h1><p>在下一章中，我们将实现事件处理，并继续完善游戏主循环。有了事件之后，我们的游戏引擎便可以说是初具雏形了。ᓚᘏᗢ</p></body></html></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.tonys-studio.top">Tony Lewis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/">https://blog.tonys-studio.top/posts/Game-Engine-0-to-1-02-Something-on-the-Screen/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Game-Engine-0-to-1/">Game Engine 0 to 1</a></div><div class="post-share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_wechat"></a><a class="a2a_button_qzone"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/07/10.jpeg" onerror='onerror=null,src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Getting Started With Coq</div></div><div class="info-2"><div class="info-item-1">Introduction to Coq and environment setup</div></div></div></a><a class="pagination-related" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/04/07.jpeg" onerror='onerror=null,src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Game Engine 0 to 1 (01): It Starts Now</div></div><div class="info-2"><div class="info-item-1">Game Engine Series 01: Project setup</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/Game-Engine-0-to-1-00-Nothing-s-Here/" title="Game Engine 0 to 1 (00): Nothing&#39;s Here"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/01/07.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> May. 27th, 2025 - 19:05:29</div><div class="info-item-2">Game Engine 0 to 1 (00): Nothing&#39;s Here</div></div><div class="info-2"><div class="info-item-1">Game Engine Series 00: Prologue</div></div></div></a><a class="pagination-related" href="/posts/Game-Engine-0-to-1-01-It-Starts-Now/" title="Game Engine 0 to 1 (01): It Starts Now"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/04/07.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jun. 1st, 2025 - 14:45:32</div><div class="info-item-2">Game Engine 0 to 1 (01): It Starts Now</div></div><div class="info-2"><div class="info-item-1">Game Engine Series 01: Project setup</div></div></div></a><a class="pagination-related" href="/posts/Game-Engine-0-to-1-03-What-Fonts-Do-I-have-A-Cross-Platform-Solution/" title="Game Engine 0 to 1 (03): What Fonts Do I Have? a Cross-Platform Solution"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/06/12.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Oct. 20th, 2025 - 20:59:54</div><div class="info-item-2">Game Engine 0 to 1 (03): What Fonts Do I Have? a Cross-Platform Solution</div></div><div class="info-2"><div class="info-item-1">Game Engine Series 03: Fonts and cross-platform issues</div></div></div></a><a class="pagination-related" href="/posts/Configure-VS-for-Non-MSVC-Projects/" title="Configure Visual Studio for Non-MSVC Projects"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/07/12.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Apr. 27th, 2023 - 09:13:37</div><div class="info-item-2">Configure Visual Studio for Non-MSVC Projects</div></div><div class="info-2"><div class="info-item-1">Configure VS IntelliSense for GCC</div></div></div></a><a class="pagination-related" href="/posts/Dungeon/" title="Dungeon"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/posts/Dungeon.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jan. 4th, 2023 - 21:45:04</div><div class="info-item-2">Dungeon</div></div><div class="info-2"><div class="info-item-1">A rogue-like game developed with EasyX and FMOD in C++.</div></div></div></a><a class="pagination-related" href="/posts/Inter-Process-Communication/" title="Inter-Process Communication"><img class="cover" src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/05/03.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> Jan. 4th, 2023 - 17:56:03</div><div class="info-item-2">Inter-Process Communication</div></div><div class="info-2"><div class="info-item-1">Chapter Seven - Inter Process Communication</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/avatar.png" onerror='this.onerror=null,this.src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/missing.gif"' alt="avatar"></div><div class="author-info-name">Tony Lewis</div><div class="author-info-description">Do or do not. There is no try.</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">87</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">40</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lord-Turmoil"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Lord-Turmoil" target="_blank" title="Github"><i class="fa-brands fa-github"></i></a><a class="social-icon" href="mailto:swift-phantom@outlook.com" target="_blank" title="Email"><i class="fa-solid fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/2030942344" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Hello there!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1"><span class="toc-text">设备抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1%EF%BC%9F"><span class="toc-text">为什么需要设备抽象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1"><span class="toc-text">图形设备抽象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Infrastructure"><span class="toc-text">Infrastructure</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%88Type-Alias%EF%BC%89"><span class="toc-text">类型别名（Type Alias）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%EF%BC%88Logging%EF%BC%89"><span class="toc-text">日志输出（Logging）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="toc-text">日志配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E9%87%8C%E9%9C%80%E8%A6%81-DGEX-API%EF%BC%9F"><span class="toc-text">哪里需要 DGEX_API？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logger"><span class="toc-text">Logger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assertion"><span class="toc-text">Assertion</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pit-Fall"><span class="toc-text">Pit Fall</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%91%E5%AE%9A"><span class="toc-text">上下文绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entry-Point"><span class="toc-text">Entry Point</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA"><span class="toc-text">窗口创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%B1%9E%E6%80%A7"><span class="toc-text">窗口属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA-1"><span class="toc-text">窗口创建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E6%8E%A5%E5%8F%A3"><span class="toc-text">绘图接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-text">创建渲染器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F"><span class="toc-text">绘制顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-text">绘制指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%99%A8%E5%B0%81%E8%A3%85"><span class="toc-text">渲染器封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%9B%AE%E6%A0%87"><span class="toc-text">绘制目标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B0%81%E8%A3%85"><span class="toc-text">缓冲区封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-text">双缓冲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E5%B1%9E%E6%80%A7"><span class="toc-text">绘图属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E5%B8%B8%E9%87%8F"><span class="toc-text">颜色常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6"><span class="toc-text">图像绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6-1"><span class="toc-text">图像绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD"><span class="toc-text">图片加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BB%98%E5%88%B6"><span class="toc-text">文本绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E5%B0%81%E8%A3%85"><span class="toc-text">字体封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E5%8A%A0%E8%BD%BD"><span class="toc-text">字体加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BB%98%E5%88%B6-1"><span class="toc-text">文本绘制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-text">模块初始化接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3"><span class="toc-text">程序入口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85"><span class="toc-text">主函数封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3"><span class="toc-text">基于回调的程序入口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E5%91%8A"><span class="toc-text">预告</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Game-Engine-0-to-1-03-What-Fonts-Do-I-have-A-Cross-Platform-Solution/" title="Game Engine 0 to 1 (03): What Fonts Do I Have? a Cross-Platform Solution"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/06/12.jpeg" onerror='this.onerror=null,this.src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png"' alt="Game Engine 0 to 1 (03): What Fonts Do I Have? a Cross-Platform Solution"></a><div class="content"><a class="title" href="/posts/Game-Engine-0-to-1-03-What-Fonts-Do-I-have-A-Cross-Platform-Solution/" title="Game Engine 0 to 1 (03): What Fonts Do I Have? a Cross-Platform Solution">Game Engine 0 to 1 (03): What Fonts Do I Have? a Cross-Platform Solution</a><time datetime="2025-10-20T12:59:54.000Z" title="Created Oct. 20th, 2025 - 20:59:54 20:59:54">Oct. 20th, 2025 - 20:59:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/A-Fancy-And-Practical-Zsh-Configuration/" title="A Fancy and Practical Zsh Configuration"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/02/02.jpeg" onerror='this.onerror=null,this.src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png"' alt="A Fancy and Practical Zsh Configuration"></a><div class="content"><a class="title" href="/posts/A-Fancy-And-Practical-Zsh-Configuration/" title="A Fancy and Practical Zsh Configuration">A Fancy and Practical Zsh Configuration</a><time datetime="2025-09-26T14:15:54.000Z" title="Created Sep. 26th, 2025 - 22:15:54 22:15:54">Sep. 26th, 2025 - 22:15:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Lambda-Calculus-A-Preliminary-View/" title="Lambda Calculus: A Preliminary View"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/07/06.jpeg" onerror='this.onerror=null,this.src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png"' alt="Lambda Calculus: A Preliminary View"></a><div class="content"><a class="title" href="/posts/Lambda-Calculus-A-Preliminary-View/" title="Lambda Calculus: A Preliminary View">Lambda Calculus: A Preliminary View</a><time datetime="2025-09-16T08:25:34.000Z" title="Created Sep. 16th, 2025 - 16:25:34 16:25:34">Sep. 16th, 2025 - 16:25:34</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Music-Notation-with-Avid-Sibelius/" title="Music Notation With Avid Sibelius"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/posts/Music-Notation-with-Avid-Sibelius.jpg" onerror='this.onerror=null,this.src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png"' alt="Music Notation With Avid Sibelius"></a><div class="content"><a class="title" href="/posts/Music-Notation-with-Avid-Sibelius/" title="Music Notation With Avid Sibelius">Music Notation With Avid Sibelius</a><time datetime="2025-09-03T04:34:54.000Z" title="Created Sep. 3rd, 2025 - 12:34:54 12:34:54">Sep. 3rd, 2025 - 12:34:54</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq"><img src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/mando/07/10.jpeg" onerror='this.onerror=null,this.src="https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/404.png"' alt="Getting Started With Coq"></a><div class="content"><a class="title" href="/posts/Getting-Started-with-Coq/" title="Getting Started With Coq">Getting Started With Coq</a><time datetime="2025-08-08T04:30:12.000Z" title="Created Aug. 8th, 2025 - 12:30:12 12:30:12">Aug. 8th, 2025 - 12:30:12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://tonys-studio-1308383348.cos.ap-beijing.myqcloud.com/blog/static/cover/boba/06/08.jpeg)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Tony Lewis</span></div><div class="footer_custom_text">No bird soars too high if he soars on his own wings</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const e=()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>(e=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"forest";e.forEach((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a=`%%{init:{ 'theme':'${t}'}}%%\n`+d.textContent,i=mermaid.render(r,a),m=e=>{d.insertAdjacentHTML("afterend",e)};"string"==typeof i?m(i):i.then(({svg:e})=>m(e))})})(e);btf.addGlobalFn("themeChange",t,"mermaid"),window.loadMermaid?t():btf.getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(t)};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{let n=window.walineFn||null;const e="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,t=(n,t=document,i=window.location.pathname)=>{const o=n({el:t.querySelector("#waline-wrap"),serverURL:"https://comment.tonys-studio.top",pageview:!0,dark:'html[data-theme="dark"]',comment:!0,path:i});e&&(window.shuoshuoComment.destroyWaline=()=>{o.destroy(),t.children.length&&(t.innerHTML="",t.classList.add("no-comment"))})},i=(e,i)=>{n?t(n,e,i):btf.getCSS("https://cdn.jsdelivr.net/npm/@waline/client@2/dist/waline.min.css").then(()=>import("https://cdn.jsdelivr.net/npm/@waline/client@2/dist/waline.min.js")).then(({init:o})=>{n=o||Waline.init,t(n,e,i),window.walineFn=n})};e?window.shuoshuoComment={loadComment:i}:setTimeout(i,0)})()</script></div><script src="/static/custom.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> Loading Database</span></div><div class="local-search-input"><input placeholder="Looking for something?🔍" type="text"></div><hr><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>